{"config":{"lang":["de","en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PyADM1ODE Kalibrierung","text":"<p>Fortschrittliches Parameter-Kalibrierungs-Framework f\u00fcr PyADM1ODE Biogasanlagenmodelle.</p> <p>PyADM1ODE_calibration bietet eine vollst\u00e4ndige L\u00f6sung f\u00fcr die Kalibrierung von PyADM1ODE Modellen:</p> <ul> <li>Initialkalibrierung: Batch-Optimierung basierend auf historischen Messdaten.</li> <li>Online-Rekalibrierung: Echtzeit-Parameteranpassung w\u00e4hrend des Anlagenbetriebs.</li> <li>Mehrere Optimierungsalgorithmen: Differential Evolution, Nelder-Mead, L-BFGS-B, Particle Swarm.</li> <li>Multikriterielle Optimierung: Ausgleich mehrerer Zielgr\u00f6\u00dfen (CH\u2084, pH, VFA) mit gewichteten Zielfunktionen.</li> <li>Umfassende Validierung: G\u00fctekriterien, Residuenanalyse, Kreuzvalidierung.</li> <li>Datenmanagement: CSV/Datenbank-Import, Validierung, Ausrei\u00dfererkennung, L\u00fcckenf\u00fcllung.</li> </ul>"},{"location":"#hauptmerkmale","title":"Hauptmerkmale","text":"<ul> <li>\ud83c\udfaf Pr\u00e4zision: Hochgenaue Abstimmung von ADM1-Parametern auf reale Anlagendaten.</li> <li>\u26a1 Effizienz: Schnelle lokale Optimierer f\u00fcr den Online-Einsatz.</li> <li>\ud83d\udcca Analyse: Integrierte Sensitivit\u00e4ts- und Identifizierbarkeitsanalyse.</li> <li>\ud83d\udcbe Integration: Nahtlose Anbindung an PostgreSQL-Datenbanken und CSV-Workflows.</li> </ul>"},{"location":"#erste-schritte","title":"Erste Schritte","text":"<p>Beginnen Sie mit der Installation und folgen Sie unserem Quickstart-Guide.</p>"},{"location":"configuration/","title":"Konfiguration","text":"<p>PyADM1ODE_calibration kann \u00fcber verschiedene Wege konfiguriert werden, um den Kalibrierungsprozess an Ihre Anlage anzupassen.</p>"},{"location":"configuration/#parameter-grenzen","title":"Parameter-Grenzen","text":"<p>Die Standardgrenzen f\u00fcr ADM1-Parameter sind in <code>ParameterBounds</code> definiert. Sie k\u00f6nnen diese global oder pro Kalibrierung anpassen.</p> <pre><code>from pyadm1ode_calibration.calibration import create_default_bounds\n\nbounds = create_default_bounds()\nbounds.add_bound(\"k_dis\", lower=0.3, upper=0.8, default=0.5)\n</code></pre>"},{"location":"configuration/#datenbank-verbindung","title":"Datenbank-Verbindung","text":"<p>Die Verbindung zur PostgreSQL-Datenbank erfolgt \u00fcber Umgebungsvariablen oder ein Konfigurationsobjekt.</p>"},{"location":"configuration/#umgebungsvariablen","title":"Umgebungsvariablen","text":"Variable Beschreibung Standard <code>DB_HOST</code> Datenbank-Host <code>localhost</code> <code>DB_PORT</code> Port <code>5432</code> <code>DB_NAME</code> Datenbank-Name - <code>DB_USER</code> Benutzername - <code>DB_PASSWORD</code> Passwort -"},{"location":"configuration/#optimierer-einstellungen","title":"Optimierer-Einstellungen","text":"<p>Jeder Algorithmus hat spezifische Parameter, die \u00fcber <code>kwargs</code> an die <code>calibrate</code>-Methode \u00fcbergeben werden:</p> <ul> <li>Differential Evolution: <code>population_size</code>, <code>mutation</code>, <code>recombination</code>.</li> <li>Nelder-Mead: <code>adaptive</code>, <code>tolerance</code>.</li> <li>L-BFGS-B: <code>gtol</code>.</li> </ul>"},{"location":"configuration/#logging","title":"Logging","text":"<p>Das Framework nutzt das Standard-Python-Logging-Modul. Sie k\u00f6nnen den Detailgrad wie folgt einstellen:</p> <pre><code>import logging\nlogging.getLogger(\"pyadm1ode_calibration\").setLevel(logging.DEBUG)\n</code></pre>"},{"location":"getting-started/","title":"Erste Schritte","text":"<p>Diese Anleitung hilft Ihnen bei den ersten Schritten mit PyADM1ODE_calibration.</p>"},{"location":"getting-started/#voraussetzungen","title":"Voraussetzungen","text":"<ul> <li>Python 3.10 oder h\u00f6her.</li> <li>PyADM1ODE: Das Basispaket muss installiert sein.</li> <li>Daten: Historische Messdaten der Biogasanlage im CSV-Format (empfohlen).</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Die einfachste Methode ist die Installation via pip direkt aus dem Repository:</p> <pre><code>pip install git+https://github.com/dgaida/PyADM1ODE_calibration.git\n</code></pre> <p>F\u00fcr Entwickler empfehlen wir die Installation im Editier-Modus:</p> <pre><code>git clone https://github.com/dgaida/PyADM1ODE_calibration.git\ncd PyADM1ODE_calibration\npip install -e .\n</code></pre>"},{"location":"getting-started/#schnelldurchlauf","title":"Schnelldurchlauf","text":"<p>Ein typischer Kalibrierungs-Workflow besteht aus vier Schritten:</p> <ol> <li>Daten laden: Importieren und Validieren Ihrer Messdaten.</li> <li>Modell vorbereiten: Konfiguration Ihres PyADM1ODE-Anlagenmodells.</li> <li>Kalibrierung ausf\u00fchren: Wahl des Algorithmus und Start der Optimierung.</li> <li>Ergebnisse pr\u00fcfen: Validierung der Parameter anhand von G\u00fctekriterien.</li> </ol> <p>Sehen Sie sich das Kalibrierungs-Beispiel f\u00fcr einen detaillierten Code-Durchlauf an.</p>"},{"location":"installation/","title":"Installation","text":"<p>Detaillierte Anweisungen zur Installation von PyADM1ODE_calibration in verschiedenen Umgebungen.</p>"},{"location":"installation/#pip-installation","title":"Pip Installation","text":""},{"location":"installation/#standard-installation","title":"Standard Installation","text":"<pre><code>pip install git+https://github.com/dgaida/PyADM1ODE_calibration.git\n</code></pre>"},{"location":"installation/#mit-optionalen-abhangigkeiten","title":"Mit optionalen Abh\u00e4ngigkeiten","text":"<pre><code># F\u00fcr Entwicklung (Tests, Linting)\npip install \"pyadm1ode_calibration[dev] @ git+https://github.com/dgaida/PyADM1ODE_calibration.git\"\n\n# F\u00fcr Dokumentation\npip install \"pyadm1ode_calibration[docs] @ git+https://github.com/dgaida/PyADM1ODE_calibration.git\"\n</code></pre>"},{"location":"installation/#conda-mamba","title":"Conda / Mamba","text":"<p>Wir empfehlen die Verwendung einer dedizierten Umgebung:</p> <pre><code># Umgebung erstellen\nconda env create -f environment.yml\nconda activate biogas\n\n# Paket im Entwicklungsmodus installieren\npip install -e .\n</code></pre>"},{"location":"installation/#datenbank-abhangigkeiten","title":"Datenbank-Abh\u00e4ngigkeiten","text":"<p>Wenn Sie die PostgreSQL-Integration nutzen m\u00f6chten, stellen Sie sicher, dass die entsprechenden Client-Bibliotheken auf Ihrem System installiert sind:</p> <ul> <li>Linux (Debian/Ubuntu): <code>sudo apt-get install libpq-dev</code></li> <li>macOS: <code>brew install postgresql</code></li> </ul>"},{"location":"installation/#verifizierung","title":"Verifizierung","text":"<p>Nach der Installation k\u00f6nnen Sie die korrekte Funktion wie folgt pr\u00fcfen:</p> <pre><code>import pyadm1ode_calibration\nprint(pyadm1ode_calibration.__version__)\n</code></pre>"},{"location":"troubleshooting/","title":"Fehlerbehebung","text":"<p>H\u00e4ufige Probleme und deren L\u00f6sungen.</p>"},{"location":"troubleshooting/#simulation-konvergiert-nicht","title":"Simulation konvergiert nicht","text":"<ul> <li>Ursache: Zu aggressive Parameter\u00e4nderungen oder instabile Anfangswerte.</li> <li>L\u00f6sung: Verkleinern Sie die Parameter-Grenzen (<code>bounds</code>) oder nutzen Sie <code>max_parameter_change</code> bei der Online-Kalibrierung.</li> </ul>"},{"location":"troubleshooting/#datenbank-verbindungsfehler","title":"Datenbank-Verbindungsfehler","text":"<ul> <li>Ursache: Falsche Umgebungsvariablen oder fehlende Berechtigungen.</li> <li>L\u00f6sung: Pr\u00fcfen Sie <code>DB_HOST</code>, <code>DB_NAME</code> etc. Stellen Sie sicher, dass PostgreSQL l\u00e4uft und Verbindungen akzeptiert.</li> </ul>"},{"location":"troubleshooting/#langsame-kalibrierung","title":"Langsame Kalibrierung","text":"<ul> <li>Ursache: Zu viele Parameter oder zu viele Iterationen bei der Differential Evolution.</li> <li>L\u00f6sung: F\u00fchren Sie zuerst eine Sensitivit\u00e4tsanalyse durch, um die wichtigsten Parameter zu identifizieren. Nutzen Sie lokale Optimierer (Nelder-Mead) f\u00fcr die Feinabstimmung.</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#pyadm1ode_calibration.calibration.Calibrator","title":"<code>pyadm1ode_calibration.calibration.Calibrator(plant, verbose=True)</code>","text":"<p>Orchestration layer for calibration workflows.</p> <p>Provides a simplified interface for running both initial and online calibrations on a plant model.</p> <p>Parameters:</p> Name Type Description Default <code>plant</code> <p>The PyADM1ODE plant model instance.</p> required <code>verbose</code> <code>bool</code> <p>Whether to enable verbose logging. Defaults to True.</p> <code>True</code> Source code in <code>pyadm1ode_calibration/calibration/__init__.py</code> <pre><code>def __init__(self, plant, verbose: bool = True):\n    self.plant = plant\n    self.verbose = verbose\n    self.initial_calibrator = InitialCalibrator(plant, verbose)\n    self.online_calibrator = OnlineCalibrator(plant, verbose)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.Calibrator-functions","title":"Functions","text":""},{"location":"api/#pyadm1ode_calibration.calibration.Calibrator.apply_calibration","title":"<code>apply_calibration(result)</code>","text":"<p>Apply calibration results to the plant model.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>CalibrationResult</code> <p>Result containing new parameters.</p> required Source code in <code>pyadm1ode_calibration/calibration/__init__.py</code> <pre><code>def apply_calibration(self, result: CalibrationResult):\n    \"\"\"\n    Apply calibration results to the plant model.\n\n    Args:\n        result (CalibrationResult): Result containing new parameters.\n    \"\"\"\n    self.online_calibrator.apply_calibration(result)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.Calibrator.run_initial_calibration","title":"<code>run_initial_calibration(measurements, parameters, **kwargs)</code>","text":"<p>Run initial batch calibration from historical data.</p> <p>Parameters:</p> Name Type Description Default <code>measurements</code> <p>Historical measurement data.</p> required <code>parameters</code> <p>List of parameter names to calibrate.</p> required <code>**kwargs</code> <p>Additional settings for InitialCalibrator.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>CalibrationResult</code> <p>Results of the calibration.</p> Source code in <code>pyadm1ode_calibration/calibration/__init__.py</code> <pre><code>def run_initial_calibration(self, measurements, parameters, **kwargs):\n    \"\"\"\n    Run initial batch calibration from historical data.\n\n    Args:\n        measurements: Historical measurement data.\n        parameters: List of parameter names to calibrate.\n        **kwargs: Additional settings for InitialCalibrator.\n\n    Returns:\n        CalibrationResult: Results of the calibration.\n    \"\"\"\n    return self.initial_calibrator.calibrate(measurements, parameters, **kwargs)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.Calibrator.run_online_calibration","title":"<code>run_online_calibration(measurements, parameters, **kwargs)</code>","text":"<p>Run online re-calibration for real-time adjustments.</p> <p>Parameters:</p> Name Type Description Default <code>measurements</code> <p>Recent measurement data.</p> required <code>parameters</code> <p>List of parameter names to calibrate.</p> required <code>**kwargs</code> <p>Additional settings for OnlineCalibrator.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>CalibrationResult</code> <p>Results of the calibration.</p> Source code in <code>pyadm1ode_calibration/calibration/__init__.py</code> <pre><code>def run_online_calibration(self, measurements, parameters, **kwargs):\n    \"\"\"\n    Run online re-calibration for real-time adjustments.\n\n    Args:\n        measurements: Recent measurement data.\n        parameters: List of parameter names to calibrate.\n        **kwargs: Additional settings for OnlineCalibrator.\n\n    Returns:\n        CalibrationResult: Results of the calibration.\n    \"\"\"\n    return self.online_calibrator.calibrate(measurements, parameters, **kwargs)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.InitialCalibrator","title":"<code>pyadm1ode_calibration.calibration.InitialCalibrator(plant, verbose=True)</code>","text":"<p>               Bases: <code>BaseCalibrator</code></p> <p>Initial calibrator for ADM1 parameters from historical data.</p> <p>This calibrator is designed for batch optimization using a window of historical measurement data. It supports multi-objective optimization, sensitivity analysis, and cross-validation.</p> <p>Parameters:</p> Name Type Description Default <code>plant</code> <code>Any</code> <p>The PyADM1ODE plant model to calibrate.</p> required <code>verbose</code> <code>bool</code> <p>Whether to enable verbose output. Defaults to True.</p> <code>True</code> Source code in <code>pyadm1ode_calibration/calibration/methods/initial.py</code> <pre><code>def __init__(self, plant: Any, verbose: bool = True):\n    super().__init__(plant, verbose)\n    self.parameter_bounds = create_default_bounds()\n    self.validator = CalibrationValidator(plant, verbose=False)\n    self.sensitivity_analyzer = SensitivityAnalyzer(plant, self.simulator, verbose)\n    self.identifiability_analyzer = IdentifiabilityAnalyzer(plant, self.sensitivity_analyzer, verbose)\n    self._optimization_history: List[Dict[str, Any]] = []\n    self._best_objective_value: float = float(\"inf\")\n    self._original_parameters: Dict[str, float] = self._get_current_parameters()\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.InitialCalibrator-functions","title":"Functions","text":""},{"location":"api/#pyadm1ode_calibration.calibration.InitialCalibrator.calibrate","title":"<code>calibrate(measurements, parameters, bounds=None, method='differential_evolution', objectives=None, weights=None, validation_split=0.2, max_iterations=100, population_size=15, tolerance=0.0001, sensitivity_analysis=True, use_constraints=False, **kwargs)</code>","text":"<p>Run the initial calibration workflow.</p> <p>Parameters:</p> Name Type Description Default <code>measurements</code> <code>MeasurementData</code> <p>Historical measurement data for calibration.</p> required <code>parameters</code> <code>List[str]</code> <p>Names of parameters to optimize.</p> required <code>bounds</code> <code>Optional[Dict[str, Tuple[float, float]]]</code> <p>Custom search bounds for parameters.</p> <code>None</code> <code>method</code> <code>str</code> <p>Optimization algorithm name. Defaults to 'differential_evolution'.</p> <code>'differential_evolution'</code> <code>objectives</code> <code>Optional[List[str]]</code> <p>List of objective variables (e.g., ['Q_ch4', 'pH']).</p> <code>None</code> <code>weights</code> <code>Optional[Dict[str, float]]</code> <p>Weights for different objectives in the cost function.</p> <code>None</code> <code>validation_split</code> <code>float</code> <p>Fraction of data to use for out-of-sample validation. Defaults to 0.2.</p> <code>0.2</code> <code>max_iterations</code> <code>int</code> <p>Maximum number of optimizer iterations. Defaults to 100.</p> <code>100</code> <code>population_size</code> <code>int</code> <p>Population size for evolutionary algorithms. Defaults to 15.</p> <code>15</code> <code>tolerance</code> <code>float</code> <p>Convergence tolerance. Defaults to 1e-4.</p> <code>0.0001</code> <code>sensitivity_analysis</code> <code>bool</code> <p>Whether to perform sensitivity analysis after calibration.</p> <code>True</code> <code>use_constraints</code> <code>bool</code> <p>Whether to apply parameter constraints. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the optimizer.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>CalibrationResult</code> <code>CalibrationResult</code> <p>The calibration results including optimized parameters and metrics.</p> Source code in <code>pyadm1ode_calibration/calibration/methods/initial.py</code> <pre><code>def calibrate(\n    self,\n    measurements: MeasurementData,\n    parameters: List[str],\n    bounds: Optional[Dict[str, Tuple[float, float]]] = None,\n    method: str = \"differential_evolution\",\n    objectives: Optional[List[str]] = None,\n    weights: Optional[Dict[str, float]] = None,\n    validation_split: float = 0.2,\n    max_iterations: int = 100,\n    population_size: int = 15,\n    tolerance: float = 1e-4,\n    sensitivity_analysis: bool = True,\n    use_constraints: bool = False,\n    **kwargs: Any,\n) -&gt; CalibrationResult:\n    \"\"\"\n    Run the initial calibration workflow.\n\n    Args:\n        measurements (MeasurementData): Historical measurement data for calibration.\n        parameters (List[str]): Names of parameters to optimize.\n        bounds (Optional[Dict[str, Tuple[float, float]]]): Custom search bounds for parameters.\n        method (str): Optimization algorithm name. Defaults to 'differential_evolution'.\n        objectives (Optional[List[str]]): List of objective variables (e.g., ['Q_ch4', 'pH']).\n        weights (Optional[Dict[str, float]]): Weights for different objectives in the cost function.\n        validation_split (float): Fraction of data to use for out-of-sample validation. Defaults to 0.2.\n        max_iterations (int): Maximum number of optimizer iterations. Defaults to 100.\n        population_size (int): Population size for evolutionary algorithms. Defaults to 15.\n        tolerance (float): Convergence tolerance. Defaults to 1e-4.\n        sensitivity_analysis (bool): Whether to perform sensitivity analysis after calibration.\n        use_constraints (bool): Whether to apply parameter constraints. Defaults to False.\n        **kwargs (Any): Additional keyword arguments passed to the optimizer.\n\n    Returns:\n        CalibrationResult: The calibration results including optimized parameters and metrics.\n    \"\"\"\n    start_time = time.time()\n    if objectives is None:\n        objectives = [\"Q_ch4\"]\n\n    # Split data\n    train_data, val_data = self._split_data(measurements, validation_split)\n\n    initial_params = self.parameter_bounds.get_default_values(parameters)\n    param_bounds = self._setup_bounds(parameters, bounds)\n\n    # Create objective function\n    def simulator_wrapper(params: Dict[str, float]) -&gt; Dict[str, np.ndarray]:\n        return self.simulator.simulate_with_parameters(params, train_data)\n\n    measurements_dict: Dict[str, np.ndarray] = {}\n    for obj in objectives:\n        try:\n            measurements_dict[obj] = train_data.get_measurement(obj).values\n        except Exception:\n            continue\n\n    objective_func: Callable[[np.ndarray], float]\n    if weights is None:\n        objective_func = WeightedSumObjective(\n            simulator=simulator_wrapper,\n            measurements_dict=measurements_dict,\n            objectives=objectives,\n            parameter_names=parameters,\n            error_metric=\"rmse\",\n            normalize=True,\n        )\n    else:\n        objective_func = MultiObjectiveFunction(\n            simulator=simulator_wrapper,\n            measurements_dict=measurements_dict,\n            objectives=objectives,\n            weights=weights,\n            parameter_names=parameters,\n            error_metric=\"rmse\",\n            normalize=True,\n        )\n\n    # Constraints\n    obj_func_final: Callable[[np.ndarray], float]\n    if use_constraints:\n        constraints = ParameterConstraints()\n        for param, (lb, ub) in param_bounds.items():\n            constraints.add_box_constraint(param, lb, ub, hard=True)\n\n        def penalized_objective(x: np.ndarray) -&gt; float:\n            params = {name: val for name, val in zip(parameters, x)}\n            return objective_func(x) + constraints.calculate_penalty(params)\n\n        obj_func_final = penalized_objective\n    else:\n        obj_func_final = objective_func\n\n    optimizer_kwargs = {**kwargs}\n    optimizer_kwargs[\"tolerance\"] = tolerance\n    if method in [\"differential_evolution\", \"de\"]:\n        optimizer_kwargs[\"population_size\"] = population_size\n\n    optimizer = create_optimizer(\n        method=method,\n        bounds=param_bounds,\n        max_iterations=max_iterations,\n        verbose=self.verbose,\n        **optimizer_kwargs,\n    )\n\n    initial_guess = (\n        np.array([initial_params[p] for p in parameters]) if method in [\"nelder_mead\", \"nm\", \"lbfgsb\", \"powell\"] else None\n    )\n    opt_result = optimizer.optimize(obj_func_final, initial_guess=initial_guess)\n\n    # Validation\n    validation_metrics: Dict[str, float] = {}\n    if len(val_data) &gt; 0:\n        val_result = self.validator.validate(\n            parameters=opt_result.parameter_dict, measurements=val_data, objectives=objectives\n        )\n        for obj, metrics in val_result.items():\n            validation_metrics.update(\n                {f\"{obj}_rmse\": float(metrics.rmse), f\"{obj}_r2\": float(metrics.r2), f\"{obj}_nse\": float(metrics.nse)}\n            )\n\n    # Sensitivity\n    sensitivity_results: Dict[str, float] = {}\n    if sensitivity_analysis and opt_result.success:\n        sens = self.sensitivity_analyzer.analyze(opt_result.parameter_dict, train_data, objectives)\n        sensitivity_results = {p: float(max(abs(s) for s in r.sensitivity_indices.values())) for p, r in sens.items()}\n\n    return CalibrationResult(\n        success=opt_result.success,\n        parameters=opt_result.parameter_dict,\n        initial_parameters=initial_params,\n        objective_value=float(opt_result.fun),\n        n_iterations=int(opt_result.nit),\n        execution_time=time.time() - start_time,\n        method=method,\n        message=str(opt_result.message) if hasattr(opt_result, \"message\") else \"Optimization completed\",\n        validation_metrics=validation_metrics,\n        sensitivity=sensitivity_results,\n        history=opt_result.history,\n    )\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.InitialCalibrator.identifiability_analysis","title":"<code>identifiability_analysis(parameters, measurements)</code>","text":"<p>Perform parameter identifiability analysis.</p> <p>Checks for parameter correlations and information content in the data.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Dict[str, float]</code> <p>Parameter set to analyze.</p> required <code>measurements</code> <code>MeasurementData</code> <p>Data window for simulation.</p> required <p>Returns:</p> Name Type Description <code>IdentifiabilityResult</code> <code>Dict[str, IdentifiabilityResult]</code> <p>Analysis results including correlation matrix.</p> Source code in <code>pyadm1ode_calibration/calibration/methods/initial.py</code> <pre><code>def identifiability_analysis(\n    self, parameters: Dict[str, float], measurements: MeasurementData\n) -&gt; Dict[str, IdentifiabilityResult]:\n    \"\"\"\n    Perform parameter identifiability analysis.\n\n    Checks for parameter correlations and information content in the data.\n\n    Args:\n        parameters (Dict[str, float]): Parameter set to analyze.\n        measurements (MeasurementData): Data window for simulation.\n\n    Returns:\n        IdentifiabilityResult: Analysis results including correlation matrix.\n    \"\"\"\n    return self.identifiability_analyzer.analyze(parameters, measurements)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.InitialCalibrator.sensitivity_analysis","title":"<code>sensitivity_analysis(parameters, measurements, objectives=None)</code>","text":"<p>Perform local sensitivity analysis for given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Dict[str, float]</code> <p>Parameter set to analyze.</p> required <code>measurements</code> <code>MeasurementData</code> <p>Data window for simulation.</p> required <code>objectives</code> <code>Optional[List[str]]</code> <p>List of objective variables.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, SensitivityResult]</code> <p>Dict[str, SensitivityResult]: Mapping of parameter names to sensitivity indices.</p> Source code in <code>pyadm1ode_calibration/calibration/methods/initial.py</code> <pre><code>def sensitivity_analysis(\n    self, parameters: Dict[str, float], measurements: MeasurementData, objectives: Optional[List[str]] = None\n) -&gt; Dict[str, SensitivityResult]:\n    \"\"\"\n    Perform local sensitivity analysis for given parameters.\n\n    Args:\n        parameters (Dict[str, float]): Parameter set to analyze.\n        measurements (MeasurementData): Data window for simulation.\n        objectives (Optional[List[str]]): List of objective variables.\n\n    Returns:\n        Dict[str, SensitivityResult]: Mapping of parameter names to sensitivity indices.\n    \"\"\"\n    return self.sensitivity_analyzer.analyze(parameters, measurements, objectives)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.OnlineCalibrator","title":"<code>pyadm1ode_calibration.calibration.OnlineCalibrator(plant, verbose=True, parameter_bounds=None)</code>","text":"<p>               Bases: <code>BaseCalibrator</code></p> <p>Online calibrator for real-time parameter adjustment.</p> <p>Performs fast, bounded re-calibration when model predictions deviate from measurements. It is optimized for speed and stability, ensuring that parameters do not drift too far from their physical meanings.</p> <p>Parameters:</p> Name Type Description Default <code>plant</code> <code>Any</code> <p>The PyADM1ODE plant model to calibrate.</p> required <code>verbose</code> <code>bool</code> <p>Whether to enable verbose logging. Defaults to True.</p> <code>True</code> <code>parameter_bounds</code> <code>Optional[ParameterBounds]</code> <p>Custom parameter bounds manager.</p> <code>None</code> Source code in <code>pyadm1ode_calibration/calibration/methods/online.py</code> <pre><code>def __init__(self, plant: Any, verbose: bool = True, parameter_bounds: Optional[ParameterBounds] = None):\n    super().__init__(plant, verbose)\n    self.parameter_bounds: ParameterBounds = parameter_bounds or create_default_bounds()\n    self.validator: CalibrationValidator = CalibrationValidator(plant, verbose=False)\n    self.trigger: OnlineCalibrationTrigger = OnlineCalibrationTrigger()\n    self.state: OnlineState = OnlineState()\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.OnlineCalibrator-functions","title":"Functions","text":""},{"location":"api/#pyadm1ode_calibration.calibration.OnlineCalibrator.apply_calibration","title":"<code>apply_calibration(result)</code>","text":"<p>Apply calibrated parameters to the underlying plant model.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>CalibrationResult</code> <p>The result containing new parameter values.</p> required Source code in <code>pyadm1ode_calibration/calibration/methods/online.py</code> <pre><code>def apply_calibration(self, result: CalibrationResult) -&gt; None:\n    \"\"\"\n    Apply calibrated parameters to the underlying plant model.\n\n    Args:\n        result (CalibrationResult): The result containing new parameter values.\n    \"\"\"\n    for component in self.plant.components.values():\n        if component.component_type.value == \"digester\":\n            component.apply_calibration_parameters(result.parameters)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.OnlineCalibrator.calibrate","title":"<code>calibrate(measurements, parameters=None, current_parameters=None, variance_threshold=0.15, max_parameter_change=0.2, time_window=7, method='nelder_mead', max_iterations=50, objectives=None, weights=None, use_constraints=True, **kwargs)</code>","text":"<p>Perform online re-calibration with bounded parameter adjustments.</p> <p>Parameters:</p> Name Type Description Default <code>measurements</code> <code>MeasurementData</code> <p>Recent measurement data window.</p> required <code>parameters</code> <code>Optional[List[str]]</code> <p>Parameters to adjust. If None, uses history.</p> <code>None</code> <code>current_parameters</code> <code>Optional[Dict[str, float]]</code> <p>Current values. If None, gets from plant.</p> <code>None</code> <code>variance_threshold</code> <code>float</code> <p>Variance threshold for triggering (0-1).</p> <code>0.15</code> <code>max_parameter_change</code> <code>float</code> <p>Max relative parameter change (0.0 to 1.0).</p> <code>0.2</code> <code>time_window</code> <code>int</code> <p>Number of days of recent data to use for optimization.</p> <code>7</code> <code>method</code> <code>str</code> <p>Optimization method name. Defaults to 'nelder_mead'.</p> <code>'nelder_mead'</code> <code>max_iterations</code> <code>int</code> <p>Maximum optimization iterations. Defaults to 50.</p> <code>50</code> <code>objectives</code> <code>Optional[List[str]]</code> <p>List of outputs to match (e.g., ['Q_ch4']).</p> <code>None</code> <code>weights</code> <code>Optional[Dict[str, float]]</code> <p>Objective weights for multi-objective cost.</p> <code>None</code> <code>use_constraints</code> <code>bool</code> <p>Whether to apply parameter box constraints.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Extra settings passed to the optimizer.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>CalibrationResult</code> <code>CalibrationResult</code> <p>Results of the online calibration step.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no parameters are specified and no history is available.</p> Source code in <code>pyadm1ode_calibration/calibration/methods/online.py</code> <pre><code>def calibrate(\n    self,\n    measurements: MeasurementData,\n    parameters: Optional[List[str]] = None,\n    current_parameters: Optional[Dict[str, float]] = None,\n    variance_threshold: float = 0.15,\n    max_parameter_change: float = 0.20,\n    time_window: int = 7,\n    method: str = \"nelder_mead\",\n    max_iterations: int = 50,\n    objectives: Optional[List[str]] = None,\n    weights: Optional[Dict[str, float]] = None,\n    use_constraints: bool = True,\n    **kwargs: Any,\n) -&gt; CalibrationResult:\n    \"\"\"\n    Perform online re-calibration with bounded parameter adjustments.\n\n    Args:\n        measurements (MeasurementData): Recent measurement data window.\n        parameters (Optional[List[str]]): Parameters to adjust. If None, uses history.\n        current_parameters (Optional[Dict[str, float]]): Current values. If None, gets from plant.\n        variance_threshold (float): Variance threshold for triggering (0-1).\n        max_parameter_change (float): Max relative parameter change (0.0 to 1.0).\n        time_window (int): Number of days of recent data to use for optimization.\n        method (str): Optimization method name. Defaults to 'nelder_mead'.\n        max_iterations (int): Maximum optimization iterations. Defaults to 50.\n        objectives (Optional[List[str]]): List of outputs to match (e.g., ['Q_ch4']).\n        weights (Optional[Dict[str, float]]): Objective weights for multi-objective cost.\n        use_constraints (bool): Whether to apply parameter box constraints.\n        **kwargs (Any): Extra settings passed to the optimizer.\n\n    Returns:\n        CalibrationResult: Results of the online calibration step.\n\n    Raises:\n        ValueError: If no parameters are specified and no history is available.\n    \"\"\"\n    start_time = time.time()\n    if objectives is None:\n        objectives = [\"Q_ch4\", \"pH\"]\n\n    if parameters is None:\n        if self.state.parameter_history:\n            parameters = list(self.state.parameter_history[-1].parameters.keys())\n        else:\n            raise ValueError(\"No parameters specified and no calibration history available\")\n\n    if current_parameters is None:\n        current_parameters = self._get_current_parameters()\n\n    windowed_data = self._extract_time_window(measurements, time_window)\n    current_variance = self._calculate_prediction_variance(windowed_data, current_parameters, objectives)\n    self.state.current_variance = current_variance\n\n    param_bounds = self._setup_online_bounds(parameters, current_parameters, max_parameter_change)\n\n    def simulator_wrapper(params: Dict[str, float]) -&gt; Dict[str, np.ndarray]:\n        return self.simulator.simulate_with_parameters(params, windowed_data)\n\n    measurements_dict: Dict[str, np.ndarray] = {\n        obj: windowed_data.get_measurement(obj).values for obj in objectives if obj in windowed_data.data.columns\n    }\n\n    objective_func: Callable[[np.ndarray], float] = MultiObjectiveFunction(\n        simulator=simulator_wrapper,\n        measurements_dict=measurements_dict,\n        objectives=objectives,\n        weights=weights or {obj: 1.0 / len(objectives) for obj in objectives},\n        parameter_names=parameters,\n        error_metric=\"rmse\",\n        normalize=True,\n    )\n\n    obj_func_final: Callable[[np.ndarray], float]\n    if use_constraints:\n        constraints = ParameterConstraints()\n        for p, (lb, ub) in param_bounds.items():\n            constraints.add_box_constraint(p, lb, ub, hard=True)\n\n        def penalized_objective(x: np.ndarray) -&gt; float:\n            params = {name: val for name, val in zip(parameters, x)}\n            return objective_func(x) + constraints.calculate_penalty(params)\n\n        obj_func_final = penalized_objective\n    else:\n        obj_func_final = objective_func\n\n    optimizer = create_optimizer(\n        method=method, bounds=param_bounds, max_iterations=max_iterations, verbose=self.verbose, **kwargs\n    )\n\n    initial_guess = np.array(\n        [current_parameters.get(p, self.parameter_bounds.get_default_values([p])[p]) for p in parameters]\n    )\n    opt_result = optimizer.optimize(obj_func_final, initial_guess=initial_guess)\n\n    validation_metrics: Dict[str, float] = {}\n    if opt_result.success:\n        val_res = self.validator.validate(\n            parameters=opt_result.parameter_dict, measurements=windowed_data, objectives=objectives\n        )\n        validation_metrics = {f\"{obj}_{k}\": float(getattr(m, k)) for obj, m in val_res.items() for k in [\"rmse\", \"r2\"]}\n\n    self.state.total_calibrations += 1\n    self.state.last_calibration_time = datetime.now()\n\n    history_entry = ParameterChangeHistory(\n        timestamp=datetime.now(),\n        parameters=opt_result.parameter_dict.copy(),\n        trigger_reason=\"variance_threshold\" if current_variance &gt; variance_threshold else \"manual\",\n        objective_value=float(opt_result.fun),\n        variance=float(current_variance),\n        success=bool(opt_result.success),\n    )\n    self.state.parameter_history.append(history_entry)\n\n    return CalibrationResult(\n        success=opt_result.success,\n        parameters=opt_result.parameter_dict,\n        initial_parameters=current_parameters,\n        objective_value=float(opt_result.fun),\n        n_iterations=int(opt_result.nit),\n        execution_time=time.time() - start_time,\n        method=method,\n        message=str(getattr(opt_result, \"message\", \"Online calibration completed\")),\n        validation_metrics=validation_metrics,\n    )\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.OnlineCalibrator.should_recalibrate","title":"<code>should_recalibrate(recent_measurements, objectives=None)</code>","text":"<p>Check if re-calibration should be triggered based on prediction error.</p> <p>Parameters:</p> Name Type Description Default <code>recent_measurements</code> <code>MeasurementData</code> <p>Recent plant data.</p> required <code>objectives</code> <code>Optional[List[str]]</code> <p>Variables to monitor for error.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[bool, str]</code> <p>Tuple[bool, str]: (should_recalibrate, reason_string).</p> Source code in <code>pyadm1ode_calibration/calibration/methods/online.py</code> <pre><code>def should_recalibrate(\n    self, recent_measurements: MeasurementData, objectives: Optional[List[str]] = None\n) -&gt; Tuple[bool, str]:\n    \"\"\"\n    Check if re-calibration should be triggered based on prediction error.\n\n    Args:\n        recent_measurements (MeasurementData): Recent plant data.\n        objectives (Optional[List[str]]): Variables to monitor for error.\n\n    Returns:\n        Tuple[bool, str]: (should_recalibrate, reason_string).\n    \"\"\"\n    if not self.trigger.enabled:\n        return False, \"Disabled\"\n\n    if objectives is None:\n        objectives = [\"Q_ch4\", \"pH\"]\n\n    if self.state.last_calibration_time:\n        hours = (datetime.now() - self.state.last_calibration_time).total_seconds() / 3600\n        if hours &lt; self.trigger.time_threshold:\n            return False, f\"Too soon since last calibration ({hours:.1f}h)\"\n\n    variance = self._calculate_prediction_variance(recent_measurements, self._get_current_parameters(), objectives)\n    self.state.current_variance = variance\n\n    if variance &gt; self.trigger.variance_threshold:\n        self.state.consecutive_violations += 1\n        if self.state.consecutive_violations &gt;= self.trigger.consecutive_violations:\n            return True, f\"Variance {variance:.4f} &gt; {self.trigger.variance_threshold}\"\n    else:\n        self.state.consecutive_violations = 0\n\n    return False, \"Prediction within accuracy threshold\"\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.MeasurementData","title":"<code>pyadm1ode_calibration.io.MeasurementData(data, metadata=None)</code>","text":"<p>Container for biogas plant measurement data.</p> <p>This class manages time-series data from biogas plants, providing methods for loading, validation, cleaning (outlier removal), and pre-processing (gap filling, resampling).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame containing measurements. If a 'timestamp' column exists, it will be converted to datetime and used as the index.</p> required <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary containing contextual information (e.g., plant ID, location).</p> <code>None</code> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def __init__(self, data: pd.DataFrame, metadata: Optional[Dict[str, Any]] = None):\n    self.data = data\n    self.metadata = metadata or {}\n\n    if \"timestamp\" in self.data.columns:\n        if not pd.api.types.is_datetime64_any_dtype(self.data[\"timestamp\"]):\n            self.data[\"timestamp\"] = pd.to_datetime(self.data[\"timestamp\"])\n        self.data = self.data.set_index(\"timestamp\").sort_index()\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.MeasurementData-functions","title":"Functions","text":""},{"location":"api/#pyadm1ode_calibration.io.MeasurementData.fill_gaps","title":"<code>fill_gaps(columns=None, method='interpolate', **kwargs)</code>","text":"<p>Fill missing values (NaNs) in the data.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Optional[List[str]]</code> <p>Columns to fill.</p> <code>None</code> <code>method</code> <code>str</code> <p>Fill method ('interpolate', 'forward', 'backward', 'mean', 'median').</p> <code>'interpolate'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for filling (e.g., 'limit').</p> <code>{}</code> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def fill_gaps(self, columns: Optional[List[str]] = None, method: str = \"interpolate\", **kwargs: Any) -&gt; None:\n    \"\"\"\n    Fill missing values (NaNs) in the data.\n\n    Args:\n        columns (Optional[List[str]]): Columns to fill.\n        method (str): Fill method ('interpolate', 'forward', 'backward', 'mean', 'median').\n        **kwargs (Any): Additional arguments for filling (e.g., 'limit').\n    \"\"\"\n    if columns is None:\n        columns = self.data.columns.tolist()\n\n    for col in columns:\n        if col not in self.data.columns:\n            continue\n        if method == \"interpolate\":\n            limit = kwargs.get(\"limit\", None)\n            self.data[col] = self.data[col].interpolate(method=\"linear\", limit=limit)\n        elif method == \"forward\":\n            limit = kwargs.get(\"limit\", None)\n            self.data[col] = self.data[col].ffill(limit=limit)\n        elif method == \"backward\":\n            limit = kwargs.get(\"limit\", None)\n            self.data[col] = self.data[col].bfill(limit=limit)\n        elif method == \"mean\":\n            self.data[col] = self.data[col].fillna(self.data[col].mean())\n        elif method == \"median\":\n            self.data[col] = self.data[col].fillna(self.data[col].median())\n        else:\n            raise ValueError(f\"Unknown fill method: {method}\")\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.MeasurementData.from_csv","title":"<code>from_csv(filepath, timestamp_column='timestamp', sep=',', parse_dates=True, resample=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load measurement data from a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the CSV file.</p> required <code>timestamp_column</code> <code>str</code> <p>Name of the column containing time information.</p> <code>'timestamp'</code> <code>sep</code> <code>str</code> <p>CSV delimiter. Defaults to ','.</p> <code>','</code> <code>parse_dates</code> <code>bool</code> <p>Whether to parse dates. Defaults to True.</p> <code>True</code> <code>resample</code> <code>Optional[str]</code> <p>Frequency string to resample to (e.g., '1h').</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to pd.read_csv.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>MeasurementData</code> <code>MeasurementData</code> <p>A new instance with the loaded data.</p> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>@classmethod\ndef from_csv(\n    cls,\n    filepath: str,\n    timestamp_column: str = \"timestamp\",\n    sep: str = \",\",\n    parse_dates: bool = True,\n    resample: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; \"MeasurementData\":\n    \"\"\"\n    Load measurement data from a CSV file.\n\n    Args:\n        filepath (str): Path to the CSV file.\n        timestamp_column (str): Name of the column containing time information.\n        sep (str): CSV delimiter. Defaults to ','.\n        parse_dates (bool): Whether to parse dates. Defaults to True.\n        resample (Optional[str]): Frequency string to resample to (e.g., '1h').\n        **kwargs (Any): Additional arguments passed to pd.read_csv.\n\n    Returns:\n        MeasurementData: A new instance with the loaded data.\n    \"\"\"\n    data = pd.read_csv(filepath, sep=sep, **kwargs)\n    if timestamp_column in data.columns:\n        data[\"timestamp\"] = pd.to_datetime(data[timestamp_column])\n        if timestamp_column != \"timestamp\":\n            data = data.drop(columns=[timestamp_column])\n    instance = cls(data)\n    if resample is not None:\n        instance.resample(resample)\n    return instance\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.MeasurementData.get_measurement","title":"<code>get_measurement(column, start_time=None, end_time=None)</code>","text":"<p>Get a specific measurement series, optionally windowed.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Name of the measurement column.</p> required <code>start_time</code> <code>Optional[datetime]</code> <p>Start of window.</p> <code>None</code> <code>end_time</code> <code>Optional[datetime]</code> <p>End of window.</p> <code>None</code> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: The requested time series.</p> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def get_measurement(\n    self, column: str, start_time: Optional[Union[str, datetime]] = None, end_time: Optional[Union[str, datetime]] = None\n) -&gt; pd.Series:\n    \"\"\"\n    Get a specific measurement series, optionally windowed.\n\n    Args:\n        column (str): Name of the measurement column.\n        start_time (Optional[datetime]): Start of window.\n        end_time (Optional[datetime]): End of window.\n\n    Returns:\n        pd.Series: The requested time series.\n    \"\"\"\n    if column not in self.data.columns:\n        raise ValueError(f\"Column '{column}' not found\")\n    series = self.data[column]\n    if start_time is not None or end_time is not None:\n        series = series.loc[start_time:end_time]  # type: ignore\n    return series\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.MeasurementData.get_substrate_feeds","title":"<code>get_substrate_feeds(substrate_columns=None)</code>","text":"<p>Extract substrate feed rates as a 2D numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>substrate_columns</code> <code>Optional[List[str]]</code> <p>Column names for substrates.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Matrix of feed rates.</p> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def get_substrate_feeds(self, substrate_columns: Optional[List[str]] = None) -&gt; np.ndarray:\n    \"\"\"\n    Extract substrate feed rates as a 2D numpy array.\n\n    Args:\n        substrate_columns (Optional[List[str]]): Column names for substrates.\n\n    Returns:\n        np.ndarray: Matrix of feed rates.\n    \"\"\"\n    if substrate_columns is None:\n        substrate_columns = [col for col in self.data.columns if col.startswith(\"Q_sub\")]\n    if not substrate_columns:\n        raise ValueError(\"No substrate columns found\")\n    return self.data[substrate_columns].values\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.MeasurementData.get_time_window","title":"<code>get_time_window(start_time, end_time)</code>","text":"<p>Create a new MeasurementData instance for a specific time window.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>Union[str, datetime]</code> <p>Start timestamp.</p> required <code>end_time</code> <code>Union[str, datetime]</code> <p>End timestamp.</p> required <p>Returns:</p> Name Type Description <code>MeasurementData</code> <code>MeasurementData</code> <p>A subset of the data.</p> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def get_time_window(self, start_time: Union[str, datetime], end_time: Union[str, datetime]) -&gt; \"MeasurementData\":\n    \"\"\"\n    Create a new MeasurementData instance for a specific time window.\n\n    Args:\n        start_time (Union[str, datetime]): Start timestamp.\n        end_time (Union[str, datetime]): End timestamp.\n\n    Returns:\n        MeasurementData: A subset of the data.\n    \"\"\"\n    windowed_data = self.data.loc[start_time:end_time].copy()  # type: ignore\n    return MeasurementData(windowed_data, metadata=self.metadata.copy())\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.MeasurementData.remove_outliers","title":"<code>remove_outliers(columns=None, method='zscore', threshold=3.0, **kwargs)</code>","text":"<p>Detect and remove outliers from specified columns.</p> <p>Outliers are replaced with NaN.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Optional[List[str]]</code> <p>Columns to check. Defaults to all numeric.</p> <code>None</code> <code>method</code> <code>str</code> <p>Detection method ('zscore', 'iqr', 'moving_window').</p> <code>'zscore'</code> <code>threshold</code> <code>float</code> <p>Threshold for outlier detection.</p> <code>3.0</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the detection method.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Total number of outliers removed.</p> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def remove_outliers(\n    self, columns: Optional[List[str]] = None, method: str = \"zscore\", threshold: float = 3.0, **kwargs: Any\n) -&gt; int:\n    \"\"\"\n    Detect and remove outliers from specified columns.\n\n    Outliers are replaced with NaN.\n\n    Args:\n        columns (Optional[List[str]]): Columns to check. Defaults to all numeric.\n        method (str): Detection method ('zscore', 'iqr', 'moving_window').\n        threshold (float): Threshold for outlier detection.\n        **kwargs (Any): Additional arguments for the detection method.\n\n    Returns:\n        int: Total number of outliers removed.\n    \"\"\"\n    if columns is None:\n        columns = self.data.select_dtypes(include=[np.number]).columns.tolist()\n\n    n_outliers = 0\n    for col in columns:\n        if col not in self.data.columns:\n            continue\n        if method == \"zscore\":\n            is_outlier = OutlierDetector.detect_zscore(self.data[col], threshold=threshold)\n        elif method == \"iqr\":\n            is_outlier = OutlierDetector.detect_iqr(self.data[col], multiplier=threshold)\n        elif method == \"moving_window\":\n            window = kwargs.get(\"window\", 5)\n            is_outlier = OutlierDetector.detect_moving_window(self.data[col], window=window, threshold=threshold)\n        else:\n            raise ValueError(f\"Unknown outlier detection method: {method}\")\n\n        n_col_outliers = int(is_outlier.sum())\n        self.data.loc[is_outlier, col] = np.nan\n        n_outliers += n_col_outliers\n    return n_outliers\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.MeasurementData.resample","title":"<code>resample(freq, aggregation='mean')</code>","text":"<p>Resample the time series data to a new frequency.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>str</code> <p>Frequency string (e.g., '1h', '1d').</p> required <code>aggregation</code> <code>str</code> <p>Aggregation function ('mean', 'sum', 'first', 'last').</p> <code>'mean'</code> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def resample(self, freq: str, aggregation: str = \"mean\") -&gt; None:\n    \"\"\"\n    Resample the time series data to a new frequency.\n\n    Args:\n        freq (str): Frequency string (e.g., '1h', '1d').\n        aggregation (str): Aggregation function ('mean', 'sum', 'first', 'last').\n    \"\"\"\n    resampler = self.data.resample(freq)\n    if aggregation == \"mean\":\n        self.data = resampler.mean()\n    elif aggregation == \"sum\":\n        self.data = resampler.sum()\n    elif aggregation == \"first\":\n        self.data = resampler.first()\n    elif aggregation == \"last\":\n        self.data = resampler.last()\n    else:\n        raise ValueError(f\"Unknown aggregation method: {aggregation}\")\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.MeasurementData.summary","title":"<code>summary()</code>","text":"<p>Get a statistical summary of all measurement columns.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Descriptive statistics.</p> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def summary(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Get a statistical summary of all measurement columns.\n\n    Returns:\n        pd.DataFrame: Descriptive statistics.\n    \"\"\"\n    return self.data.describe()\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.MeasurementData.to_csv","title":"<code>to_csv(filepath, **kwargs)</code>","text":"<p>Save the current data to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Destination path.</p> required <code>**kwargs</code> <code>Any</code> <p>Passed to pd.DataFrame.to_csv.</p> <code>{}</code> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def to_csv(self, filepath: str, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Save the current data to a CSV file.\n\n    Args:\n        filepath (str): Destination path.\n        **kwargs (Any): Passed to pd.DataFrame.to_csv.\n    \"\"\"\n    self.data.to_csv(filepath, **kwargs)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.MeasurementData.validate","title":"<code>validate(required_columns=None, expected_ranges=None)</code>","text":"<p>Validate measurement data against schema and range expectations.</p> <p>Parameters:</p> Name Type Description Default <code>required_columns</code> <code>Optional[List[str]]</code> <p>Columns that must be present.</p> <code>None</code> <code>expected_ranges</code> <code>Optional[Dict[str, Tuple[float, float]]]</code> <p>Mapping of column names to (min, max) range tuples.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ValidationResult</code> <code>ValidationResult</code> <p>Result of the validation checks.</p> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def validate(\n    self, required_columns: Optional[List[str]] = None, expected_ranges: Optional[Dict[str, Tuple[float, float]]] = None\n) -&gt; ValidationResult:\n    \"\"\"\n    Validate measurement data against schema and range expectations.\n\n    Args:\n        required_columns (Optional[List[str]]): Columns that must be present.\n        expected_ranges (Optional[Dict[str, Tuple[float, float]]]):\n            Mapping of column names to (min, max) range tuples.\n\n    Returns:\n        ValidationResult: Result of the validation checks.\n    \"\"\"\n    if expected_ranges is None:\n        expected_ranges = {\n            \"pH\": (5.0, 9.0),\n            \"VFA\": (0.0, 20.0),\n            \"TAC\": (0.0, 50.0),\n            \"Q_gas\": (0.0, 5000.0),\n            \"Q_ch4\": (0.0, 3000.0),\n            \"T_digester\": (273.15, 333.15),\n        }\n    return DataValidator.validate(self.data, required_columns=required_columns, expected_ranges=expected_ranges)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.CSVHandler","title":"<code>pyadm1ode_calibration.io.CSVHandler(decimal_separator='.', thousands_separator=',')</code>","text":"<p>Handler for CSV file operations in PyADM1.</p> <p>Supports reading and writing various CSV formats used in biogas plant operation and laboratory analysis.</p> Example <p>handler = CSVHandler() data = handler.load_substrate_lab_data(\"lab_results.csv\")</p> <p>Initialize CSV handler.</p> <p>Parameters:</p> Name Type Description Default <code>decimal_separator</code> <code>str</code> <p>Decimal separator (\".\" or \",\")</p> <code>'.'</code> <code>thousands_separator</code> <code>str</code> <p>Thousands separator (\",\" or \".\" or \"\")</p> <code>','</code> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def __init__(self, decimal_separator: str = \".\", thousands_separator: str = \",\"):\n    \"\"\"\n    Initialize CSV handler.\n\n    Args:\n        decimal_separator: Decimal separator (\".\" or \",\")\n        thousands_separator: Thousands separator (\",\" or \".\" or \"\")\n    \"\"\"\n    self.decimal_separator = decimal_separator\n    self.thousands_separator = thousands_separator\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.CSVHandler-functions","title":"Functions","text":""},{"location":"api/#pyadm1ode_calibration.io.CSVHandler.create_template_substrate_csv","title":"<code>create_template_substrate_csv(filepath, format_type='horizontal')</code>","text":"<p>Create template CSV file for substrate data entry.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Output file path</p> required <code>format_type</code> <code>str</code> <p>\"horizontal\" or \"vertical\"</p> <code>'horizontal'</code> Example <p>handler.create_template_substrate_csv(\"template.csv\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def create_template_substrate_csv(self, filepath: str, format_type: str = \"horizontal\") -&gt; None:\n    \"\"\"\n    Create template CSV file for substrate data entry.\n\n    Args:\n        filepath: Output file path\n        format_type: \"horizontal\" or \"vertical\"\n\n    Example:\n        &gt;&gt;&gt; handler.create_template_substrate_csv(\"template.csv\")\n    \"\"\"\n    if format_type == \"horizontal\":\n        # One row per sample\n        template = pd.DataFrame(\n            columns=[\n                \"substrate_name\",\n                \"substrate_type\",\n                \"sample_date\",\n                \"TS\",\n                \"VS\",\n                \"oTS\",\n                \"foTS\",\n                \"RP\",\n                \"RL\",\n                \"RF\",\n                \"NDF\",\n                \"ADF\",\n                \"ADL\",\n                \"pH\",\n                \"NH4_N\",\n                \"TAC\",\n                \"COD_S\",\n                \"BMP\",\n                \"C_content\",\n                \"N_content\",\n                \"C_to_N\",\n            ]\n        )\n\n        # Add example row\n        template.loc[0] = [\n            \"Maize silage\",\n            \"maize\",\n            \"2024-01-15\",\n            32.5,\n            96.2,\n            31.3,\n            28.5,\n            8.5,\n            3.2,\n            21.5,\n            42.1,\n            22.3,\n            2.1,\n            3.9,\n            0.5,\n            11.0,\n            18.5,\n            345.0,\n            45.2,\n            1.8,\n            25.1,\n        ]\n\n    else:  # vertical\n        template = pd.DataFrame(\n            {\n                \"Parameter\": [\n                    \"Substrate name\",\n                    \"Substrate type\",\n                    \"TS\",\n                    \"VS\",\n                    \"RP\",\n                    \"RL\",\n                    \"NDF\",\n                    \"ADF\",\n                    \"ADL\",\n                    \"pH\",\n                    \"NH4-N\",\n                    \"TAC\",\n                    \"COD_S\",\n                    \"BMP\",\n                ],\n                \"Value\": [\"Maize silage\", \"maize\", 32.5, 96.2, 8.5, 3.2, 42.1, 22.3, 2.1, 3.9, 0.5, 11.0, 18.5, 345.0],\n                \"Unit\": [\n                    \"\",\n                    \"\",\n                    \"% FM\",\n                    \"% TS\",\n                    \"% TS\",\n                    \"% TS\",\n                    \"% TS\",\n                    \"% TS\",\n                    \"% TS\",\n                    \"-\",\n                    \"g/L\",\n                    \"mmol/L\",\n                    \"g/L\",\n                    \"L CH4/kg oTS\",\n                ],\n            }\n        )\n\n    template.to_csv(filepath, index=False)\n    print(f\"\u2713 Created template CSV at {filepath}\")\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.CSVHandler.export_measurement_data","title":"<code>export_measurement_data(data, filepath, sep=',', encoding='utf-8', include_index=True)</code>","text":"<p>Export measurement data to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame with measurements</p> required <code>filepath</code> <code>str</code> <p>Output file path</p> required <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <code>include_index</code> <code>bool</code> <p>Include index (timestamp) in output</p> <code>True</code> Example <p>handler.export_measurement_data(measurements, \"export.csv\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def export_measurement_data(\n    self, data: pd.DataFrame, filepath: str, sep: str = \",\", encoding: str = \"utf-8\", include_index: bool = True\n) -&gt; None:\n    \"\"\"\n    Export measurement data to CSV.\n\n    Args:\n        data: DataFrame with measurements\n        filepath: Output file path\n        sep: Column separator\n        encoding: File encoding\n        include_index: Include index (timestamp) in output\n\n    Example:\n        &gt;&gt;&gt; handler.export_measurement_data(measurements, \"export.csv\")\n    \"\"\"\n    data.to_csv(filepath, sep=sep, encoding=encoding, index=include_index)\n    print(f\"\u2713 Exported measurement data to {filepath} ({len(data)} rows)\")\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.CSVHandler.export_parameter_table","title":"<code>export_parameter_table(data, filepath, sep=',', encoding='utf-8')</code>","text":"<p>Export parameter table to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame with parameters</p> required <code>filepath</code> <code>str</code> <p>Output file path</p> required <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> Example <p>handler.export_parameter_table(params_df, \"parameters.csv\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def export_parameter_table(self, data: pd.DataFrame, filepath: str, sep: str = \",\", encoding: str = \"utf-8\") -&gt; None:\n    \"\"\"\n    Export parameter table to CSV.\n\n    Args:\n        data: DataFrame with parameters\n        filepath: Output file path\n        sep: Column separator\n        encoding: File encoding\n\n    Example:\n        &gt;&gt;&gt; handler.export_parameter_table(params_df, \"parameters.csv\")\n    \"\"\"\n    data.to_csv(filepath, sep=sep, encoding=encoding)\n    print(f\"\u2713 Exported parameter table to {filepath}\")\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.CSVHandler.export_simulation_results","title":"<code>export_simulation_results(results, filepath, sep=',', encoding='utf-8', flatten_components=True)</code>","text":"<p>Export simulation results to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>List[Dict[str, Any]]</code> <p>List of result dicts from plant.simulate()</p> required <code>filepath</code> <code>str</code> <p>Output file path</p> required <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <code>flatten_components</code> <code>bool</code> <p>Flatten component results into columns</p> <code>True</code> Example <p>results = plant.simulate(duration=30, dt=1/24) handler.export_simulation_results(results, \"simulation.csv\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def export_simulation_results(\n    self,\n    results: List[Dict[str, Any]],\n    filepath: str,\n    sep: str = \",\",\n    encoding: str = \"utf-8\",\n    flatten_components: bool = True,\n) -&gt; None:\n    \"\"\"\n    Export simulation results to CSV.\n\n    Args:\n        results: List of result dicts from plant.simulate()\n        filepath: Output file path\n        sep: Column separator\n        encoding: File encoding\n        flatten_components: Flatten component results into columns\n\n    Example:\n        &gt;&gt;&gt; results = plant.simulate(duration=30, dt=1/24)\n        &gt;&gt;&gt; handler.export_simulation_results(results, \"simulation.csv\")\n    \"\"\"\n    if not results:\n        warnings.warn(\"No results to export\")\n        return\n\n    # Convert to DataFrame\n    if flatten_components:\n        # Flatten structure: time, component1_metric1, component1_metric2, ...\n        rows = []\n        for result in results:\n            row = {\"time\": result[\"time\"]}\n\n            for comp_id, comp_data in result[\"components\"].items():\n                for metric, value in comp_data.items():\n                    # Skip nested dicts (like gas_storage)\n                    if isinstance(value, dict):\n                        continue\n                    col_name = f\"{comp_id}_{metric}\"\n                    row[col_name] = value\n\n            rows.append(row)\n\n        df = pd.DataFrame(rows)\n    else:\n        # Simple format: just time and first component's data\n        first_comp_id = list(results[0][\"components\"].keys())[0]\n        rows = []\n        for result in results:\n            row = {\"time\": result[\"time\"]}\n            row.update(result[\"components\"][first_comp_id])\n            # Remove nested dicts\n            row = {k: v for k, v in row.items() if not isinstance(v, dict)}\n            rows.append(row)\n\n        df = pd.DataFrame(rows)\n\n    # Export\n    df.to_csv(filepath, sep=sep, encoding=encoding, index=False)\n    print(f\"\u2713 Exported simulation results to {filepath} ({len(df)} time points)\")\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.CSVHandler.export_substrate_data","title":"<code>export_substrate_data(data, filepath, sep=',', encoding='utf-8')</code>","text":"<p>Export substrate data to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Dict[str, Any], DataFrame]</code> <p>Dict or DataFrame with substrate data</p> required <code>filepath</code> <code>str</code> <p>Output file path</p> required <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> Example <p>handler.export_substrate_data(substrate_data, \"export.csv\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def export_substrate_data(\n    self, data: Union[Dict[str, Any], pd.DataFrame], filepath: str, sep: str = \",\", encoding: str = \"utf-8\"\n) -&gt; None:\n    \"\"\"\n    Export substrate data to CSV.\n\n    Args:\n        data: Dict or DataFrame with substrate data\n        filepath: Output file path\n        sep: Column separator\n        encoding: File encoding\n\n    Example:\n        &gt;&gt;&gt; handler.export_substrate_data(substrate_data, \"export.csv\")\n    \"\"\"\n    if isinstance(data, dict):\n        df = pd.DataFrame([data])\n    else:\n        df = data\n\n    df.to_csv(filepath, sep=sep, encoding=encoding, index=False)\n    print(f\"\u2713 Exported substrate data to {filepath}\")\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.CSVHandler.load_measurement_data","title":"<code>load_measurement_data(filepath, timestamp_column='timestamp', sep=',', encoding='utf-8', parse_dates=True, resample=None)</code>","text":"<p>Load time series measurement data from CSV.</p> <p>Expected columns: - timestamp (or Zeit, Zeitstempel) - Q_sub_* (substrate feeds) - pH, VFA, TAC, FOS_TAC - T_digester - Q_gas, Q_ch4, Q_co2, CH4_content, P_gas - P_el, P_th</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to CSV file</p> required <code>timestamp_column</code> <code>str</code> <p>Name of timestamp column</p> <code>'timestamp'</code> <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <code>parse_dates</code> <code>bool</code> <p>Parse timestamp column</p> <code>True</code> <code>resample</code> <code>Optional[str]</code> <p>Resample frequency (e.g., \"1h\", \"1d\")</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with measurements</p> Example <p>handler = CSVHandler() data = handler.load_measurement_data( ...     \"plant_data.csv\", ...     resample=\"1h\" ... )</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def load_measurement_data(\n    self,\n    filepath: str,\n    timestamp_column: str = \"timestamp\",\n    sep: str = \",\",\n    encoding: str = \"utf-8\",\n    parse_dates: bool = True,\n    resample: Optional[str] = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Load time series measurement data from CSV.\n\n    Expected columns:\n    - timestamp (or Zeit, Zeitstempel)\n    - Q_sub_* (substrate feeds)\n    - pH, VFA, TAC, FOS_TAC\n    - T_digester\n    - Q_gas, Q_ch4, Q_co2, CH4_content, P_gas\n    - P_el, P_th\n\n    Args:\n        filepath: Path to CSV file\n        timestamp_column: Name of timestamp column\n        sep: Column separator\n        encoding: File encoding\n        parse_dates: Parse timestamp column\n        resample: Resample frequency (e.g., \"1h\", \"1d\")\n\n    Returns:\n        DataFrame with measurements\n\n    Example:\n        &gt;&gt;&gt; handler = CSVHandler()\n        &gt;&gt;&gt; data = handler.load_measurement_data(\n        ...     \"plant_data.csv\",\n        ...     resample=\"1h\"\n        ... )\n    \"\"\"\n    # Auto-detect separator\n    if sep == \"auto\":\n        sep = self._detect_separator(filepath)\n\n    # Read CSV\n    df = pd.read_csv(filepath, sep=sep, encoding=encoding)\n\n    # Map column names\n    df = self._map_column_names(df)\n\n    # Parse timestamp\n    if timestamp_column in df.columns:\n        if parse_dates:\n            df[timestamp_column] = pd.to_datetime(df[timestamp_column])\n        df = df.set_index(timestamp_column).sort_index()\n\n    # Resample if requested\n    if resample is not None:\n        df = df.resample(resample).mean()\n\n    return df\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.CSVHandler.load_multiple_substrate_samples","title":"<code>load_multiple_substrate_samples(filepath, sep=',', encoding='utf-8', date_column='sample_date', name_column='substrate_name')</code>","text":"<p>Load multiple substrate samples from CSV.</p> <p>Expected format: Each row is one sample with columns for all parameters.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to CSV file</p> required <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <code>date_column</code> <code>str</code> <p>Name of date column</p> <code>'sample_date'</code> <code>name_column</code> <code>str</code> <p>Name of substrate name column</p> <code>'substrate_name'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with substrate data</p> Example <p>handler = CSVHandler() samples = handler.load_multiple_substrate_samples( ...     \"substrate_database.csv\" ... ) print(samples.head())</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def load_multiple_substrate_samples(\n    self,\n    filepath: str,\n    sep: str = \",\",\n    encoding: str = \"utf-8\",\n    date_column: str = \"sample_date\",\n    name_column: str = \"substrate_name\",\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Load multiple substrate samples from CSV.\n\n    Expected format: Each row is one sample with columns for all parameters.\n\n    Args:\n        filepath: Path to CSV file\n        sep: Column separator\n        encoding: File encoding\n        date_column: Name of date column\n        name_column: Name of substrate name column\n\n    Returns:\n        DataFrame with substrate data\n\n    Example:\n        &gt;&gt;&gt; handler = CSVHandler()\n        &gt;&gt;&gt; samples = handler.load_multiple_substrate_samples(\n        ...     \"substrate_database.csv\"\n        ... )\n        &gt;&gt;&gt; print(samples.head())\n    \"\"\"\n    df = pd.read_csv(filepath, sep=sep, encoding=encoding)\n\n    # Map column names\n    df = self._map_column_names(df)\n\n    # Parse date column\n    if date_column in df.columns:\n        df[date_column] = pd.to_datetime(df[date_column])\n\n    return df\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.CSVHandler.load_parameter_table","title":"<code>load_parameter_table(filepath, sep=',', encoding='utf-8', index_col=None)</code>","text":"<p>Load parameter table from CSV.</p> <p>Expected format: - Rows: Parameters - Columns: Different scenarios/substrates</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to CSV file</p> required <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <code>index_col</code> <code>Optional[str]</code> <p>Column to use as index (usually parameter name)</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with parameters</p> Example <p>params = handler.load_parameter_table(\"parameters.csv\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def load_parameter_table(\n    self, filepath: str, sep: str = \",\", encoding: str = \"utf-8\", index_col: Optional[str] = None\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Load parameter table from CSV.\n\n    Expected format:\n    - Rows: Parameters\n    - Columns: Different scenarios/substrates\n\n    Args:\n        filepath: Path to CSV file\n        sep: Column separator\n        encoding: File encoding\n        index_col: Column to use as index (usually parameter name)\n\n    Returns:\n        DataFrame with parameters\n\n    Example:\n        &gt;&gt;&gt; params = handler.load_parameter_table(\"parameters.csv\")\n    \"\"\"\n    df = pd.read_csv(filepath, sep=sep, encoding=encoding, index_col=index_col)\n    return df\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.CSVHandler.load_simulation_results","title":"<code>load_simulation_results(filepath, sep=',', encoding='utf-8')</code>","text":"<p>Load simulation results from CSV.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to CSV file</p> required <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of result dicts</p> Example <p>results = handler.load_simulation_results(\"simulation.csv\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def load_simulation_results(self, filepath: str, sep: str = \",\", encoding: str = \"utf-8\") -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Load simulation results from CSV.\n\n    Args:\n        filepath: Path to CSV file\n        sep: Column separator\n        encoding: File encoding\n\n    Returns:\n        List of result dicts\n\n    Example:\n        &gt;&gt;&gt; results = handler.load_simulation_results(\"simulation.csv\")\n    \"\"\"\n    df = pd.read_csv(filepath, sep=sep, encoding=encoding)\n\n    # Convert back to results format\n    results = []\n    for _, row in df.iterrows():\n        result = {\"time\": row[\"time\"], \"components\": {}}\n\n        # Group columns by component\n        for col in df.columns:\n            if col == \"time\":\n                continue\n\n            if \"_\" in col:\n                comp_id, metric = col.split(\"_\", 1)\n                if comp_id not in result[\"components\"]:\n                    result[\"components\"][comp_id] = {}\n                result[\"components\"][comp_id][metric] = row[col]\n\n        results.append(result)\n\n    return results\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.CSVHandler.load_substrate_lab_data","title":"<code>load_substrate_lab_data(filepath, substrate_name=None, substrate_type=None, sample_date=None, sep=',', encoding='utf-8', validate=True)</code>","text":"<p>Load substrate characterization data from laboratory CSV.</p> <p>Expected columns (German or English): - Trockensubstanzgehalt (TS) [% FM] - Organische Trockensubstanz (VS) [% TS] - Fermentierbare organische Trockensubstanz (foTS) [% TS] - Rohprotein (RP) [% TS] - Rohfett (RL) [% TS] - Rohfaser (RF) [% TS] - NDF, ADF, ADL [% TS] - pH-Wert (pH) - Ammoniumstickstoff (NH4-N) [g/L or mg/L] - Alkalinit\u00e4t (TAC) [mmol/L] - Biochemisches Methanpotential (BMP) [L CH4/kg oTS] - CSB des Filtrats (COD_S) [g/L]</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to CSV file</p> required <code>substrate_name</code> <code>Optional[str]</code> <p>Substrate name (if not in file)</p> <code>None</code> <code>substrate_type</code> <code>Optional[str]</code> <p>Substrate type (maize, manure, grass, etc.)</p> <code>None</code> <code>sample_date</code> <code>Optional[Union[str, datetime]]</code> <p>Sample date (if not in file)</p> <code>None</code> <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <code>validate</code> <code>bool</code> <p>Validate data ranges</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict with substrate data</p> Example <p>handler = CSVHandler() data = handler.load_substrate_lab_data( ...     \"maize_analysis.csv\", ...     substrate_name=\"Maize silage batch 23\", ...     substrate_type=\"maize\", ...     sample_date=\"2024-01-15\" ... ) print(f\"TS: {data['TS']:.1f}% FM\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def load_substrate_lab_data(\n    self,\n    filepath: str,\n    substrate_name: Optional[str] = None,\n    substrate_type: Optional[str] = None,\n    sample_date: Optional[Union[str, datetime]] = None,\n    sep: str = \",\",\n    encoding: str = \"utf-8\",\n    validate: bool = True,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Load substrate characterization data from laboratory CSV.\n\n    Expected columns (German or English):\n    - Trockensubstanzgehalt (TS) [% FM]\n    - Organische Trockensubstanz (VS) [% TS]\n    - Fermentierbare organische Trockensubstanz (foTS) [% TS]\n    - Rohprotein (RP) [% TS]\n    - Rohfett (RL) [% TS]\n    - Rohfaser (RF) [% TS]\n    - NDF, ADF, ADL [% TS]\n    - pH-Wert (pH)\n    - Ammoniumstickstoff (NH4-N) [g/L or mg/L]\n    - Alkalinit\u00e4t (TAC) [mmol/L]\n    - Biochemisches Methanpotential (BMP) [L CH4/kg oTS]\n    - CSB des Filtrats (COD_S) [g/L]\n\n    Args:\n        filepath: Path to CSV file\n        substrate_name: Substrate name (if not in file)\n        substrate_type: Substrate type (maize, manure, grass, etc.)\n        sample_date: Sample date (if not in file)\n        sep: Column separator\n        encoding: File encoding\n        validate: Validate data ranges\n\n    Returns:\n        Dict with substrate data\n\n    Example:\n        &gt;&gt;&gt; handler = CSVHandler()\n        &gt;&gt;&gt; data = handler.load_substrate_lab_data(\n        ...     \"maize_analysis.csv\",\n        ...     substrate_name=\"Maize silage batch 23\",\n        ...     substrate_type=\"maize\",\n        ...     sample_date=\"2024-01-15\"\n        ... )\n        &gt;&gt;&gt; print(f\"TS: {data['TS']:.1f}% FM\")\n    \"\"\"\n    # Auto-detect separator if needed\n    if sep == \"auto\":\n        sep = self._detect_separator(filepath)\n\n    # Read CSV\n    df = pd.read_csv(filepath, sep=sep, encoding=encoding)\n\n    # Try to detect if file is in \"vertical\" format (parameter, value, unit)\n    if len(df.columns) &lt;= 3 and \"Parameter\" in df.columns or \"Messgr\u00f6\u00dfe\" in df.columns:\n        df = self._parse_vertical_format(df)\n\n    # Map column names\n    df = self._map_column_names(df)\n\n    # If multiple rows, take the first one (or could aggregate)\n    if len(df) &gt; 1:\n        warnings.warn(f\"CSV contains {len(df)} rows, using first row only\")\n\n    row = df.iloc[0]\n\n    # Extract data\n    result = {\n        \"substrate_name\": substrate_name or row.get(\"substrate_name\", \"Unknown\"),\n        \"substrate_type\": substrate_type or row.get(\"substrate_type\", \"unknown\"),\n        \"sample_date\": sample_date or row.get(\"sample_date\", datetime.now()),\n    }\n\n    # Add all available parameters\n    for param in [\n        \"TS\",\n        \"VS\",\n        \"oTS\",\n        \"foTS\",\n        \"RP\",\n        \"RL\",\n        \"RF\",\n        \"RA\",\n        \"NfE\",\n        \"NDF\",\n        \"ADF\",\n        \"ADL\",\n        \"pH\",\n        \"NH4_N\",\n        \"TAC\",\n        \"COD\",\n        \"COD_S\",\n        \"BMP\",\n        \"C_content\",\n        \"N_content\",\n        \"C_to_N\",\n        \"TKN\",\n    ]:\n        if param in df.columns:\n            value = row[param]\n            # Handle both scalar values and Series\n            if isinstance(value, pd.Series):\n                value = value.iloc[0] if len(value) &gt; 0 else None\n            if pd.notna(value):\n                result[param] = float(value)\n\n    # Validate if requested\n    if validate:\n        result = self._validate_substrate_data(result)\n\n    # TODO: diese Substratparameter m\u00fcssen in die substrate_....xml geschrieben werden. evtl. gibt es in einer\n    #  c# DLL auch bereits eine Methode die man aufrufen kann. glaube aber eher nicht\n\n    return result\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database","title":"<code>pyadm1ode_calibration.io.Database(connection_string=None, config=None)</code>","text":"<p>PostgreSQL database interface for PyADM1.</p> <p>Handles connection pooling, session management, and CRUD operations for all calibration-related entities.</p> <p>Parameters:</p> Name Type Description Default <code>connection_string</code> <code>Optional[str]</code> <p>Database URL.</p> <code>None</code> <code>config</code> <code>Optional[DatabaseConfig]</code> <p>Database configuration object.</p> <code>None</code> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def __init__(self, connection_string: Optional[str] = None, config: Optional[DatabaseConfig] = None):\n    self.connection_manager = ConnectionManager(connection_string, config)\n    self.engine = self.connection_manager.engine\n    self.SessionLocal = self.connection_manager.SessionLocal\n    self.connection_string = self.connection_manager.connection_string\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database-functions","title":"Functions","text":""},{"location":"api/#pyadm1ode_calibration.io.Database.close","title":"<code>close()</code>","text":"<p>Close the database connection and dispose of the engine.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"\n    Close the database connection and dispose of the engine.\n    \"\"\"\n    self.engine.dispose()\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.create_all_tables","title":"<code>create_all_tables()</code>","text":"<p>Create all tables defined in the ORM models.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def create_all_tables(self) -&gt; None:\n    \"\"\"\n    Create all tables defined in the ORM models.\n    \"\"\"\n    Base.metadata.create_all(bind=self.engine)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.create_plant","title":"<code>create_plant(plant_id, name, location=None, operator=None, V_liq=None, V_gas=None, T_ad=None, P_el_nom=None, configuration=None)</code>","text":"<p>Register a new biogas plant in the database.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Unique identifier.</p> required <code>name</code> <code>str</code> <p>Human-readable name.</p> required <code>location</code> <code>Optional[str]</code> <p>Geographic location.</p> <code>None</code> <code>operator</code> <code>Optional[str]</code> <p>Entity operating the plant.</p> <code>None</code> <code>V_liq</code> <code>Optional[float]</code> <p>Liquid volume in m3.</p> <code>None</code> <code>V_gas</code> <code>Optional[float]</code> <p>Gas volume in m3.</p> <code>None</code> <code>T_ad</code> <code>Optional[float]</code> <p>Operating temperature in K.</p> <code>None</code> <code>P_el_nom</code> <code>Optional[float]</code> <p>Nominal electrical power in kW.</p> <code>None</code> <code>configuration</code> <code>Optional[Dict]</code> <p>Additional technical configuration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Plant</code> <code>Plant</code> <p>The created plant instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If plant_id already exists.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def create_plant(\n    self,\n    plant_id: str,\n    name: str,\n    location: Optional[str] = None,\n    operator: Optional[str] = None,\n    V_liq: Optional[float] = None,\n    V_gas: Optional[float] = None,\n    T_ad: Optional[float] = None,\n    P_el_nom: Optional[float] = None,\n    configuration: Optional[Dict] = None,\n) -&gt; Plant:\n    \"\"\"\n    Register a new biogas plant in the database.\n\n    Args:\n        plant_id (str): Unique identifier.\n        name (str): Human-readable name.\n        location (Optional[str]): Geographic location.\n        operator (Optional[str]): Entity operating the plant.\n        V_liq (Optional[float]): Liquid volume in m3.\n        V_gas (Optional[float]): Gas volume in m3.\n        T_ad (Optional[float]): Operating temperature in K.\n        P_el_nom (Optional[float]): Nominal electrical power in kW.\n        configuration (Optional[Dict]): Additional technical configuration.\n\n    Returns:\n        Plant: The created plant instance.\n\n    Raises:\n        ValueError: If plant_id already exists.\n    \"\"\"\n    session = self.SessionLocal()\n    try:\n        plant = Plant(\n            id=plant_id,\n            name=name,\n            location=location,\n            operator=operator,\n            V_liq=V_liq,\n            V_gas=V_gas,\n            T_ad=T_ad,\n            P_el_nom=P_el_nom,\n            configuration=configuration,\n        )\n        session.add(plant)\n        session.commit()\n        session.refresh(plant)\n        session.expunge(plant)\n        return plant\n    except IntegrityError:\n        session.rollback()\n        raise ValueError(f\"Plant with ID '{plant_id}' already exists\")\n    finally:\n        session.close()\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.drop_all_tables","title":"<code>drop_all_tables()</code>","text":"<p>Drop all tables from the database.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def drop_all_tables(self) -&gt; None:\n    \"\"\"\n    Drop all tables from the database.\n    \"\"\"\n    Base.metadata.drop_all(bind=self.engine)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.execute_query","title":"<code>execute_query(query, params=None)</code>","text":"<p>Execute a custom read-only SQL query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>SQL query string.</p> required <code>params</code> <code>Optional[Dict[str, Any]]</code> <p>Query parameters.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Query results.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dangerous keywords are detected.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def execute_query(self, query: str, params: Optional[Dict[str, Any]] = None) -&gt; pd.DataFrame:\n    \"\"\"\n    Execute a custom read-only SQL query.\n\n    Args:\n        query (str): SQL query string.\n        params (Optional[Dict[str, Any]]): Query parameters.\n\n    Returns:\n        pd.DataFrame: Query results.\n\n    Raises:\n        ValueError: If dangerous keywords are detected.\n    \"\"\"\n    dangerous = [\"DROP\", \"DELETE\", \"TRUNCATE\", \"ALTER\"]\n    if any(kw in query.upper() for kw in dangerous):\n        raise ValueError(\"Dangerous keyword detected in query\")\n    return pd.read_sql(query, self.engine, params=params)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.from_env","title":"<code>from_env(prefix='DB')</code>  <code>classmethod</code>","text":"<p>Create a database instance from environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix for environment variables (e.g., 'DB' -&gt; 'DB_HOST').</p> <code>'DB'</code> <p>Returns:</p> Name Type Description <code>Database</code> <code>Database</code> <p>A configured database instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required variables are missing.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>@classmethod\ndef from_env(cls, prefix: str = \"DB\") -&gt; \"Database\":\n    \"\"\"\n    Create a database instance from environment variables.\n\n    Args:\n        prefix (str): Prefix for environment variables (e.g., 'DB' -&gt; 'DB_HOST').\n\n    Returns:\n        Database: A configured database instance.\n\n    Raises:\n        ValueError: If required variables are missing.\n    \"\"\"\n    import os\n    from urllib.parse import quote_plus\n\n    host = os.getenv(f\"{prefix}_HOST\", \"localhost\")\n    port = os.getenv(f\"{prefix}_PORT\", \"5432\")\n    database = os.getenv(f\"{prefix}_NAME\")\n    username = os.getenv(f\"{prefix}_USER\")\n    password = os.getenv(f\"{prefix}_PASSWORD\")\n\n    if not all([database, username, password]):\n        raise ValueError(\"Missing required environment variables\")\n\n    conn_str = f\"postgresql://{username}:{quote_plus(password)}@{host}:{port}/{database}\"\n    return cls(connection_string=conn_str)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.get_latest_calibration","title":"<code>get_latest_calibration(plant_id)</code>","text":"<p>Get the most recent calibration for a plant.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Plant ID.</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Optional[Dict[str, Any]]: Latest calibration record.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def get_latest_calibration(self, plant_id: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Get the most recent calibration for a plant.\n\n    Args:\n        plant_id (str): Plant ID.\n\n    Returns:\n        Optional[Dict[str, Any]]: Latest calibration record.\n    \"\"\"\n    cals = self.load_calibrations(plant_id, limit=1)\n    return cals[0] if cals else None\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.get_plant","title":"<code>get_plant(plant_id)</code>","text":"<p>Retrieve a plant by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>The plant identifier.</p> required <p>Returns:</p> Name Type Description <code>Plant</code> <code>Plant</code> <p>The plant instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If plant is not found.</p> <code>DatabaseError</code> <p>On SQL failure.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def get_plant(self, plant_id: str) -&gt; Plant:\n    \"\"\"\n    Retrieve a plant by its ID.\n\n    Args:\n        plant_id (str): The plant identifier.\n\n    Returns:\n        Plant: The plant instance.\n\n    Raises:\n        ValueError: If plant is not found.\n        DatabaseError: On SQL failure.\n    \"\"\"\n    session = self.SessionLocal()\n    try:\n        plant = session.query(Plant).filter(Plant.id == plant_id).first()\n        if plant is None:\n            raise ValueError(f\"Plant '{plant_id}' not found\")\n        session.expunge(plant)\n        return plant\n    except SQLAlchemyError as e:\n        raise DatabaseError(f\"Failed to retrieve plant '{plant_id}': {e}\")\n    finally:\n        session.close()\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.get_session","title":"<code>get_session()</code>","text":"<p>Context manager for SQLAlchemy database sessions.</p> <p>Yields:</p> Name Type Description <code>Session</code> <code>Session</code> <p>An active database session.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>@contextmanager\ndef get_session(self) -&gt; Session:\n    \"\"\"\n    Context manager for SQLAlchemy database sessions.\n\n    Yields:\n        Session: An active database session.\n    \"\"\"\n    session = self.SessionLocal()\n    try:\n        yield session\n        session.commit()\n    except Exception:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.get_statistics","title":"<code>get_statistics(plant_id)</code>","text":"<p>Get database usage statistics for a specific plant.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Plant ID.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Counts and time ranges of stored data.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def get_statistics(self, plant_id: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get database usage statistics for a specific plant.\n\n    Args:\n        plant_id (str): Plant ID.\n\n    Returns:\n        Dict[str, Any]: Counts and time ranges of stored data.\n    \"\"\"\n    with self.get_session() as session:\n        return {\n            \"plant_id\": plant_id,\n            \"n_measurements\": session.query(Measurement).filter(Measurement.plant_id == plant_id).count(),\n            \"n_simulations\": session.query(Simulation).filter(Simulation.plant_id == plant_id).count(),\n            \"n_calibrations\": session.query(Calibration).filter(Calibration.plant_id == plant_id).count(),\n            \"n_substrates\": session.query(Substrate).filter(Substrate.plant_id == plant_id).count(),\n            \"first_measurement\": (\n                session.query(Measurement.timestamp)\n                .filter(Measurement.plant_id == plant_id)\n                .order_by(Measurement.timestamp)\n                .first()[0]\n                if session.query(Measurement.timestamp).filter(Measurement.plant_id == plant_id).count() &gt; 0\n                else None\n            ),\n            \"last_measurement\": (\n                session.query(Measurement.timestamp)\n                .filter(Measurement.plant_id == plant_id)\n                .order_by(Measurement.timestamp.desc())\n                .first()[0]\n                if session.query(Measurement.timestamp).filter(Measurement.plant_id == plant_id).count() &gt; 0\n                else None\n            ),\n        }\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.list_plants","title":"<code>list_plants()</code>","text":"<p>List all registered plants.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: List of plant summary dictionaries.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def list_plants(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    List all registered plants.\n\n    Returns:\n        List[Dict[str, Any]]: List of plant summary dictionaries.\n    \"\"\"\n    with self.get_session() as session:\n        plants = session.query(Plant).all()\n        return [\n            {\n                \"id\": p.id,\n                \"name\": p.name,\n                \"location\": p.location,\n                \"V_liq\": p.V_liq,\n                \"V_gas\": p.V_gas,\n                \"T_ad\": p.T_ad,\n                \"created_at\": p.created_at,\n            }\n            for p in plants\n        ]\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.list_simulations","title":"<code>list_simulations(plant_id=None, scenario=None)</code>","text":"<p>List simulations matching specific criteria.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>Optional[str]</code> <p>Filter by plant.</p> <code>None</code> <code>scenario</code> <code>Optional[str]</code> <p>Filter by scenario.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: List of simulation summaries.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def list_simulations(self, plant_id: Optional[str] = None, scenario: Optional[str] = None) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    List simulations matching specific criteria.\n\n    Args:\n        plant_id (Optional[str]): Filter by plant.\n        scenario (Optional[str]): Filter by scenario.\n\n    Returns:\n        List[Dict[str, Any]]: List of simulation summaries.\n    \"\"\"\n    with self.get_session() as session:\n        query = session.query(Simulation)\n        if plant_id:\n            query = query.filter(Simulation.plant_id == plant_id)\n        if scenario:\n            query = query.filter(Simulation.scenario == scenario)\n        simulations = query.order_by(Simulation.created_at.desc()).all()\n        return [\n            {\n                \"id\": s.id,\n                \"plant_id\": s.plant_id,\n                \"name\": s.name,\n                \"scenario\": s.scenario,\n                \"duration\": s.duration,\n                \"avg_Q_ch4\": s.avg_Q_ch4,\n                \"status\": s.status,\n                \"created_at\": s.created_at,\n            }\n            for s in simulations\n        ]\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.load_calibrations","title":"<code>load_calibrations(plant_id, calibration_type=None, limit=10)</code>","text":"<p>Load past calibrations for a plant.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Plant ID.</p> required <code>calibration_type</code> <code>Optional[str]</code> <p>Filter by type.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Max records to return.</p> <code>10</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: List of calibration records.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def load_calibrations(\n    self, plant_id: str, calibration_type: Optional[str] = None, limit: int = 10\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Load past calibrations for a plant.\n\n    Args:\n        plant_id (str): Plant ID.\n        calibration_type (Optional[str]): Filter by type.\n        limit (int): Max records to return.\n\n    Returns:\n        List[Dict[str, Any]]: List of calibration records.\n    \"\"\"\n    with self.get_session() as session:\n        query = session.query(Calibration).filter(Calibration.plant_id == plant_id)\n        if calibration_type:\n            query = query.filter(Calibration.calibration_type == calibration_type)\n        cals = query.order_by(Calibration.created_at.desc()).limit(limit).all()\n        return [{c.name: getattr(cal, c.name) for c in Calibration.__table__.columns} for cal in cals]\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.load_measurements","title":"<code>load_measurements(plant_id, start_time=None, end_time=None, columns=None, source=None)</code>","text":"<p>Load measurements as a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Plant ID.</p> required <code>start_time</code> <code>Optional[datetime]</code> <p>Start of window.</p> <code>None</code> <code>end_time</code> <code>Optional[datetime]</code> <p>End of window.</p> <code>None</code> <code>columns</code> <code>Optional[List[str]]</code> <p>Specific columns to load.</p> <code>None</code> <code>source</code> <code>Optional[str]</code> <p>Filter by data source.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Measurements indexed by timestamp.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def load_measurements(self, plant_id: str, start_time=None, end_time=None, columns=None, source=None) -&gt; pd.DataFrame:\n    \"\"\"\n    Load measurements as a pandas DataFrame.\n\n    Args:\n        plant_id (str): Plant ID.\n        start_time (Optional[datetime]): Start of window.\n        end_time (Optional[datetime]): End of window.\n        columns (Optional[List[str]]): Specific columns to load.\n        source (Optional[str]): Filter by data source.\n\n    Returns:\n        pd.DataFrame: Measurements indexed by timestamp.\n    \"\"\"\n    if isinstance(start_time, str):\n        start_time = pd.to_datetime(start_time)\n    if isinstance(end_time, str):\n        end_time = pd.to_datetime(end_time)\n    with self.get_session() as session:\n        query = session.query(Measurement).filter(Measurement.plant_id == plant_id)\n        if start_time:\n            query = query.filter(Measurement.timestamp &gt;= start_time)\n        if end_time:\n            query = query.filter(Measurement.timestamp &lt;= end_time)\n        if source:\n            query = query.filter(Measurement.source == source)\n        results = query.order_by(Measurement.timestamp).all()\n        if not results:\n            return pd.DataFrame()\n        data_dict = {\"timestamp\": [r.timestamp for r in results]}\n        if columns is None:\n            columns = [\n                c.name\n                for c in Measurement.__table__.columns\n                if c.name not in [\"id\", \"plant_id\", \"timestamp\", \"source\", \"created_at\"]\n            ]\n        for col in columns:\n            data_dict[col] = [getattr(r, col) for r in results]\n        return pd.DataFrame(data_dict).set_index(\"timestamp\")\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.load_simulation","title":"<code>load_simulation(simulation_id)</code>","text":"<p>Load simulation metadata and its full time series.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_id</code> <code>str</code> <p>ID of the simulation.</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Optional[Dict[str, Any]]: Dictionary containing metadata and 'time_series' DataFrame.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def load_simulation(self, simulation_id: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Load simulation metadata and its full time series.\n\n    Args:\n        simulation_id (str): ID of the simulation.\n\n    Returns:\n        Optional[Dict[str, Any]]: Dictionary containing metadata and 'time_series' DataFrame.\n    \"\"\"\n    with self.get_session() as session:\n        sim = session.query(Simulation).filter(Simulation.id == simulation_id).first()\n        if not sim:\n            return None\n        ts = (\n            session.query(SimulationTimeSeries)\n            .filter(SimulationTimeSeries.simulation_id == simulation_id)\n            .order_by(SimulationTimeSeries.time)\n            .all()\n        )\n        df = (\n            pd.DataFrame(\n                {\n                    c.name: [getattr(t, c.name) for t in ts]\n                    for c in SimulationTimeSeries.__table__.columns\n                    if c.name not in [\"id\", \"simulation_id\"]\n                }\n            )\n            if ts\n            else pd.DataFrame()\n        )\n        return {**{c.name: getattr(sim, c.name) for c in Simulation.__table__.columns}, \"time_series\": df}\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.load_substrates","title":"<code>load_substrates(plant_id, substrate_type=None, start_date=None, end_date=None)</code>","text":"<p>Load substrate data as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Plant ID.</p> required <code>substrate_type</code> <code>Optional[str]</code> <p>Filter by type.</p> <code>None</code> <code>start_date</code> <code>Optional[datetime]</code> <p>Start date.</p> <code>None</code> <code>end_date</code> <code>Optional[datetime]</code> <p>End date.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Table of substrate analyses.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def load_substrates(\n    self,\n    plant_id: str,\n    substrate_type: Optional[str] = None,\n    start_date: Optional[Union[str, datetime]] = None,\n    end_date: Optional[Union[str, datetime]] = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Load substrate data as a DataFrame.\n\n    Args:\n        plant_id (str): Plant ID.\n        substrate_type (Optional[str]): Filter by type.\n        start_date (Optional[datetime]): Start date.\n        end_date (Optional[datetime]): End date.\n\n    Returns:\n        pd.DataFrame: Table of substrate analyses.\n    \"\"\"\n    if isinstance(start_date, str):\n        start_date = pd.to_datetime(start_date)\n    if isinstance(end_date, str):\n        end_date = pd.to_datetime(end_date)\n    with self.get_session() as session:\n        query = session.query(Substrate).filter(Substrate.plant_id == plant_id)\n        if substrate_type:\n            query = query.filter(Substrate.substrate_type == substrate_type)\n        if start_date:\n            query = query.filter(Substrate.sample_date &gt;= start_date)\n        if end_date:\n            query = query.filter(Substrate.sample_date &lt;= end_date)\n        substrates = query.order_by(Substrate.sample_date).all()\n        if not substrates:\n            return pd.DataFrame()\n        cols = [\n            \"sample_date\",\n            \"substrate_name\",\n            \"substrate_type\",\n            \"sample_id\",\n            \"TS\",\n            \"VS\",\n            \"oTS\",\n            \"foTS\",\n            \"RP\",\n            \"RL\",\n            \"RF\",\n            \"NDF\",\n            \"ADF\",\n            \"ADL\",\n            \"pH\",\n            \"NH4_N\",\n            \"TAC\",\n            \"COD_S\",\n            \"BMP\",\n            \"C_to_N\",\n            \"lab_name\",\n        ]\n        return pd.DataFrame([{c: getattr(s, c) for c in cols} for s in substrates])\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.store_calibration","title":"<code>store_calibration(plant_id, calibration_type, method, parameters, objective_value, objectives, validation_metrics=None, data_start=None, data_end=None, success=True, message=None)</code>","text":"<p>Store a calibration result.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Plant ID.</p> required <code>calibration_type</code> <code>str</code> <p>'initial' or 'online'.</p> required <code>method</code> <code>str</code> <p>Optimization method.</p> required <code>parameters</code> <code>Dict[str, float]</code> <p>Calibrated values.</p> required <code>objective_value</code> <code>float</code> <p>Final cost value.</p> required <code>objectives</code> <code>List[str]</code> <p>Variables used in objective.</p> required <code>validation_metrics</code> <code>Optional[Dict[str, float]]</code> <p>RMSE, R2 etc.</p> <code>None</code> <code>data_start</code> <code>Optional[datetime]</code> <p>Start of data window.</p> <code>None</code> <code>data_end</code> <code>Optional[datetime]</code> <p>End of data window.</p> <code>None</code> <code>success</code> <code>bool</code> <p>Whether calibration converged.</p> <code>True</code> <code>message</code> <code>Optional[str]</code> <p>Status message.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Calibration</code> <code>Calibration</code> <p>Stored record.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def store_calibration(\n    self,\n    plant_id: str,\n    calibration_type: str,\n    method: str,\n    parameters: Dict[str, float],\n    objective_value: float,\n    objectives: List[str],\n    validation_metrics: Optional[Dict[str, float]] = None,\n    data_start: Optional[datetime] = None,\n    data_end: Optional[datetime] = None,\n    success: bool = True,\n    message: Optional[str] = None,\n) -&gt; Calibration:\n    \"\"\"\n    Store a calibration result.\n\n    Args:\n        plant_id (str): Plant ID.\n        calibration_type (str): 'initial' or 'online'.\n        method (str): Optimization method.\n        parameters (Dict[str, float]): Calibrated values.\n        objective_value (float): Final cost value.\n        objectives (List[str]): Variables used in objective.\n        validation_metrics (Optional[Dict[str, float]]): RMSE, R2 etc.\n        data_start (Optional[datetime]): Start of data window.\n        data_end (Optional[datetime]): End of data window.\n        success (bool): Whether calibration converged.\n        message (Optional[str]): Status message.\n\n    Returns:\n        Calibration: Stored record.\n    \"\"\"\n    with self.get_session() as session:\n        cal = Calibration(\n            plant_id=plant_id,\n            calibration_type=calibration_type,\n            method=method,\n            parameters=parameters,\n            objective_value=objective_value,\n            objectives=objectives,\n            validation_metrics=validation_metrics,\n            data_start=data_start,\n            data_end=data_end,\n            success=success,\n            message=message,\n        )\n        session.add(cal)\n        return cal\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.store_measurements","title":"<code>store_measurements(plant_id, data, source='SCADA', validate=True)</code>","text":"<p>Bulk store measurement data for a plant.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>ID of the plant.</p> required <code>data</code> <code>DataFrame</code> <p>Measurements with 'timestamp' column.</p> required <code>source</code> <code>str</code> <p>Data source name. Defaults to 'SCADA'.</p> <code>'SCADA'</code> <code>validate</code> <code>bool</code> <p>Whether to run quality checks before storing.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of records stored.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def store_measurements(self, plant_id: str, data: pd.DataFrame, source: str = \"SCADA\", validate: bool = True) -&gt; int:\n    \"\"\"\n    Bulk store measurement data for a plant.\n\n    Args:\n        plant_id (str): ID of the plant.\n        data (pd.DataFrame): Measurements with 'timestamp' column.\n        source (str): Data source name. Defaults to 'SCADA'.\n        validate (bool): Whether to run quality checks before storing.\n\n    Returns:\n        int: Number of records stored.\n    \"\"\"\n    self.get_plant(plant_id)\n    if \"timestamp\" not in data.columns:\n        raise ValueError(\"DataFrame must have 'timestamp' column\")\n    if not pd.api.types.is_datetime64_any_dtype(data[\"timestamp\"]):\n        data[\"timestamp\"] = pd.to_datetime(data[\"timestamp\"])\n    if validate:\n        from ..validation.validators import DataValidator\n\n        DataValidator.validate(data)\n\n    records = []\n    for _, row in data.iterrows():\n        record = {\"plant_id\": plant_id, \"timestamp\": row[\"timestamp\"], \"source\": source}\n        for col in data.columns:\n            if col != \"timestamp\" and col in Measurement.__table__.columns:\n                val = row[col]\n                if pd.notna(val):\n                    record[col] = float(val) if isinstance(val, (int, float, np.number)) else val\n        records.append(record)\n    with self.get_session() as session:\n        try:\n            session.bulk_insert_mappings(Measurement, records)\n            return len(records)\n        except SQLAlchemyError as e:\n            raise DatabaseError(f\"Failed to store measurements: {e}\")\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.store_simulation","title":"<code>store_simulation(simulation_id, plant_id, results, name=None, description=None, duration=None, parameters=None, scenario='baseline')</code>","text":"<p>Store simulation metadata and time series.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_id</code> <code>str</code> <p>Unique ID for the simulation.</p> required <code>plant_id</code> <code>str</code> <p>Associated plant ID.</p> required <code>results</code> <code>List[Dict[str, Any]]</code> <p>Time-series results from simulation.</p> required <code>name</code> <code>Optional[str]</code> <p>Simulation name.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional description.</p> <code>None</code> <code>duration</code> <code>Optional[float]</code> <p>Duration in days.</p> <code>None</code> <code>parameters</code> <code>Optional[Dict]</code> <p>Parameters used in this run.</p> <code>None</code> <code>scenario</code> <code>str</code> <p>Scenario label. Defaults to 'baseline'.</p> <code>'baseline'</code> <p>Returns:</p> Name Type Description <code>Simulation</code> <code>Simulation</code> <p>Stored simulation record.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def store_simulation(\n    self,\n    simulation_id: str,\n    plant_id: str,\n    results: List[Dict[str, Any]],\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    duration: Optional[float] = None,\n    parameters: Optional[Dict] = None,\n    scenario: str = \"baseline\",\n) -&gt; Simulation:\n    \"\"\"\n    Store simulation metadata and time series.\n\n    Args:\n        simulation_id (str): Unique ID for the simulation.\n        plant_id (str): Associated plant ID.\n        results (List[Dict[str, Any]]): Time-series results from simulation.\n        name (Optional[str]): Simulation name.\n        description (Optional[str]): Optional description.\n        duration (Optional[float]): Duration in days.\n        parameters (Optional[Dict]): Parameters used in this run.\n        scenario (str): Scenario label. Defaults to 'baseline'.\n\n    Returns:\n        Simulation: Stored simulation record.\n    \"\"\"\n    self.get_plant(plant_id)\n    metrics = self._calculate_simulation_metrics(results)\n    with self.get_session() as session:\n        sim = Simulation(\n            id=simulation_id,\n            plant_id=plant_id,\n            name=name,\n            description=description,\n            duration=duration or (results[-1][\"time\"] if results else 0),\n            scenario=scenario,\n            parameters=parameters,\n            avg_Q_gas=metrics.get(\"avg_Q_gas\"),\n            avg_Q_ch4=metrics.get(\"avg_Q_ch4\"),\n            avg_CH4_content=metrics.get(\"avg_CH4_content\"),\n            avg_pH=metrics.get(\"avg_pH\"),\n            avg_VFA=metrics.get(\"avg_VFA\"),\n            total_energy=metrics.get(\"total_energy\"),\n            status=\"completed\",\n            started_at=datetime.utcnow(),\n            completed_at=datetime.utcnow(),\n        )\n        try:\n            session.add(sim)\n            session.flush()\n            ts_records = []\n            for res in results:\n                comp_data = next(iter(res[\"components\"].values()))\n                record = {\n                    \"simulation_id\": simulation_id,\n                    \"time\": res[\"time\"],\n                    \"Q_gas\": comp_data.get(\"Q_gas\"),\n                    \"Q_ch4\": comp_data.get(\"Q_ch4\"),\n                    \"Q_co2\": comp_data.get(\"Q_co2\"),\n                    \"pH\": comp_data.get(\"pH\"),\n                    \"VFA\": comp_data.get(\"VFA\"),\n                    \"TAC\": comp_data.get(\"TAC\"),\n                }\n                if record[\"Q_gas\"] and record[\"Q_ch4\"] and record[\"Q_gas\"] &gt; 0:\n                    record[\"CH4_content\"] = (record[\"Q_ch4\"] / record[\"Q_gas\"]) * 100\n                ts_records.append(record)\n            session.bulk_insert_mappings(SimulationTimeSeries, ts_records)\n            return sim\n        except IntegrityError:\n            raise ValueError(f\"Simulation with ID '{simulation_id}' already exists\")\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.Database.store_substrate","title":"<code>store_substrate(plant_id, substrate_name, substrate_type, sample_date, lab_data, sample_id=None, lab_name=None, notes=None)</code>","text":"<p>Store substrate laboratory analysis data.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Associated plant ID.</p> required <code>substrate_name</code> <code>str</code> <p>Name (e.g., 'Maize Silage').</p> required <code>substrate_type</code> <code>str</code> <p>Category.</p> required <code>sample_date</code> <code>datetime</code> <p>Date of sampling.</p> required <code>lab_data</code> <code>Dict[str, float]</code> <p>Chemical properties (TS, VS, oTS, etc.).</p> required <code>sample_id</code> <code>Optional[str]</code> <p>Lab internal ID.</p> <code>None</code> <code>lab_name</code> <code>Optional[str]</code> <p>Lab name.</p> <code>None</code> <code>notes</code> <code>Optional[str]</code> <p>Additional comments.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Substrate</code> <code>Substrate</code> <p>Stored record.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def store_substrate(\n    self,\n    plant_id: str,\n    substrate_name: str,\n    substrate_type: str,\n    sample_date: Union[str, datetime],\n    lab_data: Dict[str, float],\n    sample_id: Optional[str] = None,\n    lab_name: Optional[str] = None,\n    notes: Optional[str] = None,\n) -&gt; Substrate:\n    \"\"\"\n    Store substrate laboratory analysis data.\n\n    Args:\n        plant_id (str): Associated plant ID.\n        substrate_name (str): Name (e.g., 'Maize Silage').\n        substrate_type (str): Category.\n        sample_date (datetime): Date of sampling.\n        lab_data (Dict[str, float]): Chemical properties (TS, VS, oTS, etc.).\n        sample_id (Optional[str]): Lab internal ID.\n        lab_name (Optional[str]): Lab name.\n        notes (Optional[str]): Additional comments.\n\n    Returns:\n        Substrate: Stored record.\n    \"\"\"\n    if isinstance(sample_date, str):\n        sample_date = pd.to_datetime(sample_date)\n    session = self.SessionLocal()\n    try:\n        substrate = Substrate(\n            plant_id=plant_id,\n            substrate_name=substrate_name,\n            substrate_type=substrate_type,\n            sample_date=sample_date,\n            sample_id=sample_id,\n            lab_name=lab_name,\n            notes=notes,\n        )\n        for key, value in lab_data.items():\n            if hasattr(substrate, key):\n                setattr(substrate, key, value)\n        session.add(substrate)\n        session.commit()\n        session.refresh(substrate)\n        session.expunge(substrate)\n        return substrate\n    except Exception:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.io.DataValidator","title":"<code>pyadm1ode_calibration.io.DataValidator</code>","text":"<p>Validates measurement data quality and consistency.</p>"},{"location":"api/#pyadm1ode_calibration.io.DataValidator-functions","title":"Functions","text":""},{"location":"api/#pyadm1ode_calibration.io.DataValidator.validate","title":"<code>validate(data, required_columns=None, expected_ranges=None)</code>  <code>staticmethod</code>","text":"<p>Perform comprehensive data validation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame to validate</p> required <code>required_columns</code> <code>Optional[List[str]]</code> <p>Columns that must be present</p> <code>None</code> <code>expected_ranges</code> <code>Optional[Dict[str, Tuple[float, float]]]</code> <p>Mapping of column names to (min, max)</p> <code>None</code> <p>Returns:</p> Type Description <code>ValidationResult</code> <p>ValidationResult object</p> Source code in <code>pyadm1ode_calibration/io/validation/validators.py</code> <pre><code>@staticmethod\ndef validate(\n    data: pd.DataFrame,\n    required_columns: Optional[List[str]] = None,\n    expected_ranges: Optional[Dict[str, Tuple[float, float]]] = None,\n) -&gt; ValidationResult:\n    \"\"\"\n    Perform comprehensive data validation.\n\n    Args:\n        data: DataFrame to validate\n        required_columns: Columns that must be present\n        expected_ranges: Mapping of column names to (min, max)\n\n    Returns:\n        ValidationResult object\n    \"\"\"\n    issues = []\n    warnings = []\n    missing_counts = data.isnull().sum().to_dict()\n    missing_pct = data.isnull().mean()\n\n    # 1. Check required columns\n    if required_columns:\n        for col in required_columns:\n            if col not in data.columns:\n                issues.append(f\"Required column '{col}' is missing\")\n\n    # 2. Check for empty data\n    if data.empty:\n        issues.append(\"Dataset is empty\")\n        return ValidationResult(is_valid=False, quality_score=0.0, issues=issues, missing_data=missing_counts)\n\n    # 3. Check for missing values (NaN)\n    for col, pct in missing_pct.items():\n        if pct &gt; 0.3:\n            issues.append(f\"Column '{col}' has {pct*100:.1f}% missing values\")\n        elif pct &gt; 0:\n            warnings.append(f\"Column '{col}' has {pct*100:.1f}% missing values\")\n\n    # 4. Check expected ranges\n    if expected_ranges:\n        for col, (vmin, vmax) in expected_ranges.items():\n            if col in data.columns:\n                out_of_range = (data[col] &lt; vmin) | (data[col] &gt; vmax)\n                n_out = out_of_range.sum()\n                if n_out &gt; 0:\n                    pct = n_out / len(data)\n                    if pct &gt; 0.2:\n                        issues.append(f\"Column '{col}' has {n_out} values outside range [{vmin}, {vmax}]\")\n                    else:\n                        warnings.append(f\"Column '{col}' has {n_out} values outside range [{vmin}, {vmax}]\")\n\n    # 5. Check for duplicates in index (timestamps)\n    if data.index.duplicated().any():\n        issues.append(\"Dataset has duplicate timestamps\")\n\n    # Calculate quality score\n    quality_score = DataValidator._calculate_quality_score(len(issues), len(warnings), missing_pct.mean())\n\n    return ValidationResult(\n        is_valid=len(issues) == 0,\n        quality_score=quality_score,\n        issues=issues,\n        warnings=warnings,\n        missing_data=missing_counts,\n        statistics={\"missing_pct_avg\": float(missing_pct.mean())},\n    )\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.CalibrationValidator","title":"<code>pyadm1ode_calibration.calibration.CalibrationValidator(plant, verbose=True)</code>","text":"<p>Validator for calibrated model parameters.</p> <p>Provides methods to evaluate the goodness-of-fit of calibrated parameters on both training and out-of-sample validation data.</p> <p>Parameters:</p> Name Type Description Default <code>plant</code> <code>Any</code> <p>The PyADM1ODE plant model instance.</p> required <code>verbose</code> <code>bool</code> <p>Whether to enable verbose output. Defaults to True.</p> <code>True</code> Source code in <code>pyadm1ode_calibration/calibration/validation.py</code> <pre><code>def __init__(self, plant: Any, verbose: bool = True):\n    self.plant = plant\n    self.verbose = verbose\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.CalibrationValidator-functions","title":"Functions","text":""},{"location":"api/#pyadm1ode_calibration.calibration.CalibrationValidator.analyze_residuals","title":"<code>analyze_residuals(measurements, simulated, objectives=None)</code>","text":"<p>Perform detailed residual analysis.</p> <p>Parameters:</p> Name Type Description Default <code>measurements</code> <code>MeasurementData</code> <p>Reference measurements.</p> required <code>simulated</code> <code>Dict[str, ndarray]</code> <p>Simulated outputs.</p> required <code>objectives</code> <code>Optional[List[str]]</code> <p>Variables to analyze.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, ResidualAnalysis]</code> <p>Dict[str, ResidualAnalysis]: Analysis results for each objective.</p> Source code in <code>pyadm1ode_calibration/calibration/validation.py</code> <pre><code>def analyze_residuals(\n    self,\n    measurements: MeasurementData,\n    simulated: Dict[str, np.ndarray],\n    objectives: Optional[List[str]] = None,\n) -&gt; Dict[str, ResidualAnalysis]:\n    \"\"\"\n    Perform detailed residual analysis.\n\n    Args:\n        measurements (MeasurementData): Reference measurements.\n        simulated (Dict[str, np.ndarray]): Simulated outputs.\n        objectives (Optional[List[str]]): Variables to analyze.\n\n    Returns:\n        Dict[str, ResidualAnalysis]: Analysis results for each objective.\n    \"\"\"\n    if objectives is None:\n        objectives = list(simulated.keys())\n\n    results = {}\n    for objective in objectives:\n        if objective not in simulated:\n            continue\n\n        observed = self._extract_measurements(measurements, objective)\n        predicted = simulated[objective]\n\n        observed, predicted = self._align_arrays(observed, predicted)\n\n        if len(observed) &lt; 3:\n            continue\n\n        residuals = observed - predicted\n        std_residuals = self._standardize_residuals(residuals)\n        normality = self._test_normality(residuals)\n        autocorr = self._calculate_autocorrelation(residuals)\n        hetero = self._test_heteroscedasticity(residuals, predicted)\n        outliers = np.where(np.abs(std_residuals) &gt; 3)[0].tolist()\n\n        results[objective] = ResidualAnalysis(\n            objective=objective,\n            residuals=residuals,\n            standardized_residuals=std_residuals,\n            normality_test=normality,\n            autocorrelation=autocorr,\n            heteroscedasticity_test=hetero,\n            outlier_indices=outliers,\n        )\n\n    return results\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.CalibrationValidator.cross_validate","title":"<code>cross_validate(parameters, measurements, n_folds=5, objectives=None)</code>","text":"<p>Perform k-fold cross-validation.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Dict[str, float]</code> <p>Calibrated parameters.</p> required <code>measurements</code> <code>MeasurementData</code> <p>Full dataset to split.</p> required <code>n_folds</code> <code>int</code> <p>Number of folds. Defaults to 5.</p> <code>5</code> <code>objectives</code> <code>Optional[List[str]]</code> <p>Variables to validate.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, List[ValidationMetrics]]</code> <p>Dict[str, List[ValidationMetrics]]: List of metrics for each fold.</p> Source code in <code>pyadm1ode_calibration/calibration/validation.py</code> <pre><code>def cross_validate(\n    self,\n    parameters: Dict[str, float],\n    measurements: MeasurementData,\n    n_folds: int = 5,\n    objectives: Optional[List[str]] = None,\n) -&gt; Dict[str, List[ValidationMetrics]]:\n    \"\"\"\n    Perform k-fold cross-validation.\n\n    Args:\n        parameters (Dict[str, float]): Calibrated parameters.\n        measurements (MeasurementData): Full dataset to split.\n        n_folds (int): Number of folds. Defaults to 5.\n        objectives (Optional[List[str]]): Variables to validate.\n\n    Returns:\n        Dict[str, List[ValidationMetrics]]: List of metrics for each fold.\n    \"\"\"\n    if objectives is None:\n        objectives = [\"Q_ch4\", \"pH\", \"VFA\"]\n\n    n_samples = len(measurements)\n    fold_size = n_samples // n_folds\n    cv_results: Dict[str, List[ValidationMetrics]] = {obj: [] for obj in objectives}\n\n    for fold in range(n_folds):\n        start_idx = fold * fold_size\n        end_idx = start_idx + fold_size if fold &lt; n_folds - 1 else n_samples\n\n        val_data = measurements.data.iloc[start_idx:end_idx].copy()\n        val_measurements = type(measurements)(val_data)\n\n        fold_metrics = self.validate(parameters, val_measurements, objectives)\n        for obj, metrics in fold_metrics.items():\n            cv_results[obj].append(metrics)\n\n    return cv_results\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.CalibrationValidator.validate","title":"<code>validate(parameters, measurements, objectives=None, simulation_duration=None)</code>","text":"<p>Validate parameters against measurement data.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Dict[str, float]</code> <p>Calibrated parameters to test.</p> required <code>measurements</code> <code>MeasurementData</code> <p>Reference measurement data.</p> required <code>objectives</code> <code>Optional[List[str]]</code> <p>Variables to validate.</p> <code>None</code> <code>simulation_duration</code> <code>Optional[float]</code> <p>Duration in days.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, ValidationMetrics]</code> <p>Dict[str, ValidationMetrics]: Metrics for each objective.</p> Source code in <code>pyadm1ode_calibration/calibration/validation.py</code> <pre><code>def validate(\n    self,\n    parameters: Dict[str, float],\n    measurements: MeasurementData,\n    objectives: Optional[List[str]] = None,\n    simulation_duration: Optional[float] = None,\n) -&gt; Dict[str, ValidationMetrics]:\n    \"\"\"\n    Validate parameters against measurement data.\n\n    Args:\n        parameters (Dict[str, float]): Calibrated parameters to test.\n        measurements (MeasurementData): Reference measurement data.\n        objectives (Optional[List[str]]): Variables to validate.\n        simulation_duration (Optional[float]): Duration in days.\n\n    Returns:\n        Dict[str, ValidationMetrics]: Metrics for each objective.\n    \"\"\"\n    if objectives is None:\n        objectives = [\"Q_ch4\", \"pH\", \"VFA\"]\n\n    self._apply_parameters(parameters)\n\n    if simulation_duration is None:\n        simulation_duration = len(measurements) * (1.0 / 24.0)\n\n    simulated_outputs = self._simulate_plant(measurements, simulation_duration)\n\n    metrics = {}\n    for objective in objectives:\n        if objective not in simulated_outputs:\n            warnings.warn(f\"Objective '{objective}' not in simulation outputs\")\n            continue\n\n        observed = self._extract_measurements(measurements, objective)\n        predicted = simulated_outputs[objective]\n\n        observed, predicted = self._align_arrays(observed, predicted)\n\n        if len(observed) == 0:\n            warnings.warn(f\"No valid data for objective '{objective}'\")\n            continue\n\n        obj_metrics = self._calculate_metrics(objective, observed, predicted)\n        metrics[objective] = obj_metrics\n\n    return metrics\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.ParameterBounds","title":"<code>pyadm1ode_calibration.calibration.ParameterBounds()</code>","text":"<p>Manager for parameter bounds in ADM1 calibration.</p> <p>Provides methods for accessing bounds, validating parameters, and calculating penalties for constraint violations.</p> <p>Attributes:</p> Name Type Description <code>bounds</code> <code>Dict[str, ParameterBound]</code> <p>Dictionary mapping parameter names to ParameterBound objects</p> Example <p>bounds = ParameterBounds() bounds.add_bound(\"k_dis\", lower=0.3, upper=0.8, default=0.5) is_valid = bounds.is_within_bounds(\"k_dis\", 0.6)</p> <p>Initialize empty parameter bounds manager.</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize empty parameter bounds manager.\"\"\"\n    self.bounds: Dict[str, ParameterBound] = {}\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.ParameterBounds-functions","title":"Functions","text":""},{"location":"api/#pyadm1ode_calibration.calibration.ParameterBounds.add_bound","title":"<code>add_bound(name, lower, upper, default, bound_type=BoundType.HARD, penalty_weight=1.0, description='', unit='', substrate_dependent=False)</code>","text":"<p>Add parameter bound.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <code>lower</code> <code>float</code> <p>Lower bound</p> required <code>upper</code> <code>float</code> <p>Upper bound</p> required <code>default</code> <code>float</code> <p>Default value</p> required <code>bound_type</code> <code>BoundType</code> <p>Type of bound</p> <code>HARD</code> <code>penalty_weight</code> <code>float</code> <p>Penalty weight for soft constraints</p> <code>1.0</code> <code>description</code> <code>str</code> <p>Parameter description</p> <code>''</code> <code>unit</code> <code>str</code> <p>Parameter unit</p> <code>''</code> <code>substrate_dependent</code> <code>bool</code> <p>Whether bound varies by substrate</p> <code>False</code> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def add_bound(\n    self,\n    name: str,\n    lower: float,\n    upper: float,\n    default: float,\n    bound_type: BoundType = BoundType.HARD,\n    penalty_weight: float = 1.0,\n    description: str = \"\",\n    unit: str = \"\",\n    substrate_dependent: bool = False,\n) -&gt; None:\n    \"\"\"\n    Add parameter bound.\n\n    Args:\n        name: Parameter name\n        lower: Lower bound\n        upper: Upper bound\n        default: Default value\n        bound_type: Type of bound\n        penalty_weight: Penalty weight for soft constraints\n        description: Parameter description\n        unit: Parameter unit\n        substrate_dependent: Whether bound varies by substrate\n    \"\"\"\n    self.bounds[name] = ParameterBound(\n        name=name,\n        lower=lower,\n        upper=upper,\n        default=default,\n        bound_type=bound_type,\n        penalty_weight=penalty_weight,\n        description=description,\n        unit=unit,\n        substrate_dependent=substrate_dependent,\n    )\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.ParameterBounds.calculate_penalty","title":"<code>calculate_penalty(name, value, penalty_type='quadratic')</code>","text":"<p>Calculate penalty for parameter value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <code>value</code> <code>float</code> <p>Parameter value</p> required <code>penalty_type</code> <code>str</code> <p>Type of penalty function</p> <code>'quadratic'</code> <p>Returns:</p> Type Description <code>float</code> <p>Penalty value</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def calculate_penalty(self, name: str, value: float, penalty_type: str = \"quadratic\") -&gt; float:\n    \"\"\"\n    Calculate penalty for parameter value.\n\n    Args:\n        name: Parameter name\n        value: Parameter value\n        penalty_type: Type of penalty function\n\n    Returns:\n        Penalty value\n    \"\"\"\n    bound = self.get_bounds(name)\n    if bound is None:\n        return 0.0\n    return bound.calculate_penalty(value, penalty_type)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.ParameterBounds.calculate_total_penalty","title":"<code>calculate_total_penalty(parameters, penalty_type='quadratic')</code>","text":"<p>Calculate total penalty for all parameters.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Dict[str, float]</code> <p>Dictionary of parameter values</p> required <code>penalty_type</code> <code>str</code> <p>Type of penalty function</p> <code>'quadratic'</code> <p>Returns:</p> Type Description <code>float</code> <p>Total penalty</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def calculate_total_penalty(self, parameters: Dict[str, float], penalty_type: str = \"quadratic\") -&gt; float:\n    \"\"\"\n    Calculate total penalty for all parameters.\n\n    Args:\n        parameters: Dictionary of parameter values\n        penalty_type: Type of penalty function\n\n    Returns:\n        Total penalty\n    \"\"\"\n    total_penalty = 0.0\n    for name, value in parameters.items():\n        penalty = self.calculate_penalty(name, value, penalty_type)\n        if np.isinf(penalty):\n            return np.inf\n        total_penalty += penalty\n    return total_penalty\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.ParameterBounds.clip_to_bounds","title":"<code>clip_to_bounds(name, value)</code>","text":"<p>Clip parameter value to bounds.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <code>value</code> <code>float</code> <p>Parameter value</p> required <p>Returns:</p> Type Description <code>float</code> <p>Clipped value</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def clip_to_bounds(self, name: str, value: float) -&gt; float:\n    \"\"\"\n    Clip parameter value to bounds.\n\n    Args:\n        name: Parameter name\n        value: Parameter value\n\n    Returns:\n        Clipped value\n    \"\"\"\n    bound = self.get_bounds(name)\n    if bound is None:\n        return value\n    return bound.clip_to_bounds(value)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.ParameterBounds.get_bounds","title":"<code>get_bounds(name)</code>","text":"<p>Get bounds for parameter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <p>Returns:</p> Type Description <code>Optional[ParameterBound]</code> <p>ParameterBound object or None if not found</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def get_bounds(self, name: str) -&gt; Optional[ParameterBound]:\n    \"\"\"\n    Get bounds for parameter.\n\n    Args:\n        name: Parameter name\n\n    Returns:\n        ParameterBound object or None if not found\n    \"\"\"\n    return self.bounds.get(name)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.ParameterBounds.get_bounds_tuple","title":"<code>get_bounds_tuple(name)</code>","text":"<p>Get bounds as tuple (lower, upper).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <p>Returns:</p> Type Description <code>Optional[Tuple[float, float]]</code> <p>Tuple of (lower, upper) or None</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def get_bounds_tuple(self, name: str) -&gt; Optional[Tuple[float, float]]:\n    \"\"\"\n    Get bounds as tuple (lower, upper).\n\n    Args:\n        name: Parameter name\n\n    Returns:\n        Tuple of (lower, upper) or None\n    \"\"\"\n    bound = self.get_bounds(name)\n    if bound is None:\n        return None\n    return (bound.lower, bound.upper)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.ParameterBounds.get_default_values","title":"<code>get_default_values(parameter_names)</code>","text":"<p>Get default values for parameters.</p> <p>Parameters:</p> Name Type Description Default <code>parameter_names</code> <code>List[str]</code> <p>List of parameter names</p> required <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dictionary of default values</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def get_default_values(self, parameter_names: List[str]) -&gt; Dict[str, float]:\n    \"\"\"\n    Get default values for parameters.\n\n    Args:\n        parameter_names: List of parameter names\n\n    Returns:\n        Dictionary of default values\n    \"\"\"\n    defaults = {}\n    for name in parameter_names:\n        bound = self.get_bounds(name)\n        if bound is not None:\n            defaults[name] = bound.default\n    return defaults\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.ParameterBounds.is_within_bounds","title":"<code>is_within_bounds(name, value, tolerance=0.0)</code>","text":"<p>Check if parameter value is within bounds.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <code>value</code> <code>float</code> <p>Parameter value</p> required <code>tolerance</code> <code>float</code> <p>Tolerance for boundary</p> <code>0.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if within bounds, False otherwise</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def is_within_bounds(self, name: str, value: float, tolerance: float = 0.0) -&gt; bool:\n    \"\"\"\n    Check if parameter value is within bounds.\n\n    Args:\n        name: Parameter name\n        value: Parameter value\n        tolerance: Tolerance for boundary\n\n    Returns:\n        True if within bounds, False otherwise\n    \"\"\"\n    bound = self.get_bounds(name)\n    if bound is None:\n        return True  # No bounds defined, assume valid\n    return bound.is_within_bounds(value, tolerance)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.ParameterBounds.scale_to_unit_interval","title":"<code>scale_to_unit_interval(name, value)</code>","text":"<p>Scale parameter value to unit interval [0, 1].</p> <p>Useful for optimization algorithms that work better with normalized parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <code>value</code> <code>float</code> <p>Parameter value</p> required <p>Returns:</p> Type Description <code>float</code> <p>Scaled value in [0, 1]</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def scale_to_unit_interval(self, name: str, value: float) -&gt; float:\n    \"\"\"\n    Scale parameter value to unit interval [0, 1].\n\n    Useful for optimization algorithms that work better with\n    normalized parameters.\n\n    Args:\n        name: Parameter name\n        value: Parameter value\n\n    Returns:\n        Scaled value in [0, 1]\n    \"\"\"\n    bound = self.get_bounds(name)\n    if bound is None:\n        return value\n\n    if bound.upper == bound.lower:\n        return 0.5\n\n    return (value - bound.lower) / (bound.upper - bound.lower)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.ParameterBounds.unscale_from_unit_interval","title":"<code>unscale_from_unit_interval(name, scaled_value)</code>","text":"<p>Unscale parameter value from unit interval [0, 1].</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <code>scaled_value</code> <code>float</code> <p>Scaled value in [0, 1]</p> required <p>Returns:</p> Type Description <code>float</code> <p>Unscaled parameter value</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def unscale_from_unit_interval(self, name: str, scaled_value: float) -&gt; float:\n    \"\"\"\n    Unscale parameter value from unit interval [0, 1].\n\n    Args:\n        name: Parameter name\n        scaled_value: Scaled value in [0, 1]\n\n    Returns:\n        Unscaled parameter value\n    \"\"\"\n    bound = self.get_bounds(name)\n    if bound is None:\n        return scaled_value\n\n    return bound.lower + scaled_value * (bound.upper - bound.lower)\n</code></pre>"},{"location":"api/#pyadm1ode_calibration.calibration.ParameterBounds.validate_parameters","title":"<code>validate_parameters(parameters, raise_on_invalid=False)</code>","text":"<p>Validate all parameters against bounds.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Dict[str, float]</code> <p>Dictionary of parameter values</p> required <code>raise_on_invalid</code> <code>bool</code> <p>Raise exception if invalid</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[bool, List[str]]</code> <p>Tuple of (all_valid, list of error messages)</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def validate_parameters(self, parameters: Dict[str, float], raise_on_invalid: bool = False) -&gt; Tuple[bool, List[str]]:\n    \"\"\"\n    Validate all parameters against bounds.\n\n    Args:\n        parameters: Dictionary of parameter values\n        raise_on_invalid: Raise exception if invalid\n\n    Returns:\n        Tuple of (all_valid, list of error messages)\n    \"\"\"\n    errors = []\n\n    for name, value in parameters.items():\n        bound = self.get_bounds(name)\n        if bound is None:\n            continue\n\n        if not bound.is_within_bounds(value):\n            error = f\"Parameter '{name}' = {value:.4f} is outside bounds [{bound.lower:.4f}, {bound.upper:.4f}]\"\n            errors.append(error)\n\n    if errors and raise_on_invalid:\n        raise ValueError(\"\\n\".join(errors))\n\n    return (len(errors) == 0, errors)\n</code></pre>"},{"location":"api/calibration/","title":"Calibration API","text":""},{"location":"api/calibration/#pyadm1ode_calibration.calibration.Calibrator","title":"<code>pyadm1ode_calibration.calibration.Calibrator(plant, verbose=True)</code>","text":"<p>Orchestration layer for calibration workflows.</p> <p>Provides a simplified interface for running both initial and online calibrations on a plant model.</p> <p>Parameters:</p> Name Type Description Default <code>plant</code> <p>The PyADM1ODE plant model instance.</p> required <code>verbose</code> <code>bool</code> <p>Whether to enable verbose logging. Defaults to True.</p> <code>True</code> Source code in <code>pyadm1ode_calibration/calibration/__init__.py</code> <pre><code>def __init__(self, plant, verbose: bool = True):\n    self.plant = plant\n    self.verbose = verbose\n    self.initial_calibrator = InitialCalibrator(plant, verbose)\n    self.online_calibrator = OnlineCalibrator(plant, verbose)\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.Calibrator-functions","title":"Functions","text":""},{"location":"api/calibration/#pyadm1ode_calibration.calibration.Calibrator.apply_calibration","title":"<code>apply_calibration(result)</code>","text":"<p>Apply calibration results to the plant model.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>CalibrationResult</code> <p>Result containing new parameters.</p> required Source code in <code>pyadm1ode_calibration/calibration/__init__.py</code> <pre><code>def apply_calibration(self, result: CalibrationResult):\n    \"\"\"\n    Apply calibration results to the plant model.\n\n    Args:\n        result (CalibrationResult): Result containing new parameters.\n    \"\"\"\n    self.online_calibrator.apply_calibration(result)\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.Calibrator.run_initial_calibration","title":"<code>run_initial_calibration(measurements, parameters, **kwargs)</code>","text":"<p>Run initial batch calibration from historical data.</p> <p>Parameters:</p> Name Type Description Default <code>measurements</code> <p>Historical measurement data.</p> required <code>parameters</code> <p>List of parameter names to calibrate.</p> required <code>**kwargs</code> <p>Additional settings for InitialCalibrator.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>CalibrationResult</code> <p>Results of the calibration.</p> Source code in <code>pyadm1ode_calibration/calibration/__init__.py</code> <pre><code>def run_initial_calibration(self, measurements, parameters, **kwargs):\n    \"\"\"\n    Run initial batch calibration from historical data.\n\n    Args:\n        measurements: Historical measurement data.\n        parameters: List of parameter names to calibrate.\n        **kwargs: Additional settings for InitialCalibrator.\n\n    Returns:\n        CalibrationResult: Results of the calibration.\n    \"\"\"\n    return self.initial_calibrator.calibrate(measurements, parameters, **kwargs)\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.Calibrator.run_online_calibration","title":"<code>run_online_calibration(measurements, parameters, **kwargs)</code>","text":"<p>Run online re-calibration for real-time adjustments.</p> <p>Parameters:</p> Name Type Description Default <code>measurements</code> <p>Recent measurement data.</p> required <code>parameters</code> <p>List of parameter names to calibrate.</p> required <code>**kwargs</code> <p>Additional settings for OnlineCalibrator.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>CalibrationResult</code> <p>Results of the calibration.</p> Source code in <code>pyadm1ode_calibration/calibration/__init__.py</code> <pre><code>def run_online_calibration(self, measurements, parameters, **kwargs):\n    \"\"\"\n    Run online re-calibration for real-time adjustments.\n\n    Args:\n        measurements: Recent measurement data.\n        parameters: List of parameter names to calibrate.\n        **kwargs: Additional settings for OnlineCalibrator.\n\n    Returns:\n        CalibrationResult: Results of the calibration.\n    \"\"\"\n    return self.online_calibrator.calibrate(measurements, parameters, **kwargs)\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.InitialCalibrator","title":"<code>pyadm1ode_calibration.calibration.InitialCalibrator(plant, verbose=True)</code>","text":"<p>               Bases: <code>BaseCalibrator</code></p> <p>Initial calibrator for ADM1 parameters from historical data.</p> <p>This calibrator is designed for batch optimization using a window of historical measurement data. It supports multi-objective optimization, sensitivity analysis, and cross-validation.</p> <p>Parameters:</p> Name Type Description Default <code>plant</code> <code>Any</code> <p>The PyADM1ODE plant model to calibrate.</p> required <code>verbose</code> <code>bool</code> <p>Whether to enable verbose output. Defaults to True.</p> <code>True</code> Source code in <code>pyadm1ode_calibration/calibration/methods/initial.py</code> <pre><code>def __init__(self, plant: Any, verbose: bool = True):\n    super().__init__(plant, verbose)\n    self.parameter_bounds = create_default_bounds()\n    self.validator = CalibrationValidator(plant, verbose=False)\n    self.sensitivity_analyzer = SensitivityAnalyzer(plant, self.simulator, verbose)\n    self.identifiability_analyzer = IdentifiabilityAnalyzer(plant, self.sensitivity_analyzer, verbose)\n    self._optimization_history: List[Dict[str, Any]] = []\n    self._best_objective_value: float = float(\"inf\")\n    self._original_parameters: Dict[str, float] = self._get_current_parameters()\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.InitialCalibrator-functions","title":"Functions","text":""},{"location":"api/calibration/#pyadm1ode_calibration.calibration.InitialCalibrator.calibrate","title":"<code>calibrate(measurements, parameters, bounds=None, method='differential_evolution', objectives=None, weights=None, validation_split=0.2, max_iterations=100, population_size=15, tolerance=0.0001, sensitivity_analysis=True, use_constraints=False, **kwargs)</code>","text":"<p>Run the initial calibration workflow.</p> <p>Parameters:</p> Name Type Description Default <code>measurements</code> <code>MeasurementData</code> <p>Historical measurement data for calibration.</p> required <code>parameters</code> <code>List[str]</code> <p>Names of parameters to optimize.</p> required <code>bounds</code> <code>Optional[Dict[str, Tuple[float, float]]]</code> <p>Custom search bounds for parameters.</p> <code>None</code> <code>method</code> <code>str</code> <p>Optimization algorithm name. Defaults to 'differential_evolution'.</p> <code>'differential_evolution'</code> <code>objectives</code> <code>Optional[List[str]]</code> <p>List of objective variables (e.g., ['Q_ch4', 'pH']).</p> <code>None</code> <code>weights</code> <code>Optional[Dict[str, float]]</code> <p>Weights for different objectives in the cost function.</p> <code>None</code> <code>validation_split</code> <code>float</code> <p>Fraction of data to use for out-of-sample validation. Defaults to 0.2.</p> <code>0.2</code> <code>max_iterations</code> <code>int</code> <p>Maximum number of optimizer iterations. Defaults to 100.</p> <code>100</code> <code>population_size</code> <code>int</code> <p>Population size for evolutionary algorithms. Defaults to 15.</p> <code>15</code> <code>tolerance</code> <code>float</code> <p>Convergence tolerance. Defaults to 1e-4.</p> <code>0.0001</code> <code>sensitivity_analysis</code> <code>bool</code> <p>Whether to perform sensitivity analysis after calibration.</p> <code>True</code> <code>use_constraints</code> <code>bool</code> <p>Whether to apply parameter constraints. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the optimizer.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>CalibrationResult</code> <code>CalibrationResult</code> <p>The calibration results including optimized parameters and metrics.</p> Source code in <code>pyadm1ode_calibration/calibration/methods/initial.py</code> <pre><code>def calibrate(\n    self,\n    measurements: MeasurementData,\n    parameters: List[str],\n    bounds: Optional[Dict[str, Tuple[float, float]]] = None,\n    method: str = \"differential_evolution\",\n    objectives: Optional[List[str]] = None,\n    weights: Optional[Dict[str, float]] = None,\n    validation_split: float = 0.2,\n    max_iterations: int = 100,\n    population_size: int = 15,\n    tolerance: float = 1e-4,\n    sensitivity_analysis: bool = True,\n    use_constraints: bool = False,\n    **kwargs: Any,\n) -&gt; CalibrationResult:\n    \"\"\"\n    Run the initial calibration workflow.\n\n    Args:\n        measurements (MeasurementData): Historical measurement data for calibration.\n        parameters (List[str]): Names of parameters to optimize.\n        bounds (Optional[Dict[str, Tuple[float, float]]]): Custom search bounds for parameters.\n        method (str): Optimization algorithm name. Defaults to 'differential_evolution'.\n        objectives (Optional[List[str]]): List of objective variables (e.g., ['Q_ch4', 'pH']).\n        weights (Optional[Dict[str, float]]): Weights for different objectives in the cost function.\n        validation_split (float): Fraction of data to use for out-of-sample validation. Defaults to 0.2.\n        max_iterations (int): Maximum number of optimizer iterations. Defaults to 100.\n        population_size (int): Population size for evolutionary algorithms. Defaults to 15.\n        tolerance (float): Convergence tolerance. Defaults to 1e-4.\n        sensitivity_analysis (bool): Whether to perform sensitivity analysis after calibration.\n        use_constraints (bool): Whether to apply parameter constraints. Defaults to False.\n        **kwargs (Any): Additional keyword arguments passed to the optimizer.\n\n    Returns:\n        CalibrationResult: The calibration results including optimized parameters and metrics.\n    \"\"\"\n    start_time = time.time()\n    if objectives is None:\n        objectives = [\"Q_ch4\"]\n\n    # Split data\n    train_data, val_data = self._split_data(measurements, validation_split)\n\n    initial_params = self.parameter_bounds.get_default_values(parameters)\n    param_bounds = self._setup_bounds(parameters, bounds)\n\n    # Create objective function\n    def simulator_wrapper(params: Dict[str, float]) -&gt; Dict[str, np.ndarray]:\n        return self.simulator.simulate_with_parameters(params, train_data)\n\n    measurements_dict: Dict[str, np.ndarray] = {}\n    for obj in objectives:\n        try:\n            measurements_dict[obj] = train_data.get_measurement(obj).values\n        except Exception:\n            continue\n\n    objective_func: Callable[[np.ndarray], float]\n    if weights is None:\n        objective_func = WeightedSumObjective(\n            simulator=simulator_wrapper,\n            measurements_dict=measurements_dict,\n            objectives=objectives,\n            parameter_names=parameters,\n            error_metric=\"rmse\",\n            normalize=True,\n        )\n    else:\n        objective_func = MultiObjectiveFunction(\n            simulator=simulator_wrapper,\n            measurements_dict=measurements_dict,\n            objectives=objectives,\n            weights=weights,\n            parameter_names=parameters,\n            error_metric=\"rmse\",\n            normalize=True,\n        )\n\n    # Constraints\n    obj_func_final: Callable[[np.ndarray], float]\n    if use_constraints:\n        constraints = ParameterConstraints()\n        for param, (lb, ub) in param_bounds.items():\n            constraints.add_box_constraint(param, lb, ub, hard=True)\n\n        def penalized_objective(x: np.ndarray) -&gt; float:\n            params = {name: val for name, val in zip(parameters, x)}\n            return objective_func(x) + constraints.calculate_penalty(params)\n\n        obj_func_final = penalized_objective\n    else:\n        obj_func_final = objective_func\n\n    optimizer_kwargs = {**kwargs}\n    optimizer_kwargs[\"tolerance\"] = tolerance\n    if method in [\"differential_evolution\", \"de\"]:\n        optimizer_kwargs[\"population_size\"] = population_size\n\n    optimizer = create_optimizer(\n        method=method,\n        bounds=param_bounds,\n        max_iterations=max_iterations,\n        verbose=self.verbose,\n        **optimizer_kwargs,\n    )\n\n    initial_guess = (\n        np.array([initial_params[p] for p in parameters]) if method in [\"nelder_mead\", \"nm\", \"lbfgsb\", \"powell\"] else None\n    )\n    opt_result = optimizer.optimize(obj_func_final, initial_guess=initial_guess)\n\n    # Validation\n    validation_metrics: Dict[str, float] = {}\n    if len(val_data) &gt; 0:\n        val_result = self.validator.validate(\n            parameters=opt_result.parameter_dict, measurements=val_data, objectives=objectives\n        )\n        for obj, metrics in val_result.items():\n            validation_metrics.update(\n                {f\"{obj}_rmse\": float(metrics.rmse), f\"{obj}_r2\": float(metrics.r2), f\"{obj}_nse\": float(metrics.nse)}\n            )\n\n    # Sensitivity\n    sensitivity_results: Dict[str, float] = {}\n    if sensitivity_analysis and opt_result.success:\n        sens = self.sensitivity_analyzer.analyze(opt_result.parameter_dict, train_data, objectives)\n        sensitivity_results = {p: float(max(abs(s) for s in r.sensitivity_indices.values())) for p, r in sens.items()}\n\n    return CalibrationResult(\n        success=opt_result.success,\n        parameters=opt_result.parameter_dict,\n        initial_parameters=initial_params,\n        objective_value=float(opt_result.fun),\n        n_iterations=int(opt_result.nit),\n        execution_time=time.time() - start_time,\n        method=method,\n        message=str(opt_result.message) if hasattr(opt_result, \"message\") else \"Optimization completed\",\n        validation_metrics=validation_metrics,\n        sensitivity=sensitivity_results,\n        history=opt_result.history,\n    )\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.InitialCalibrator.identifiability_analysis","title":"<code>identifiability_analysis(parameters, measurements)</code>","text":"<p>Perform parameter identifiability analysis.</p> <p>Checks for parameter correlations and information content in the data.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Dict[str, float]</code> <p>Parameter set to analyze.</p> required <code>measurements</code> <code>MeasurementData</code> <p>Data window for simulation.</p> required <p>Returns:</p> Name Type Description <code>IdentifiabilityResult</code> <code>Dict[str, IdentifiabilityResult]</code> <p>Analysis results including correlation matrix.</p> Source code in <code>pyadm1ode_calibration/calibration/methods/initial.py</code> <pre><code>def identifiability_analysis(\n    self, parameters: Dict[str, float], measurements: MeasurementData\n) -&gt; Dict[str, IdentifiabilityResult]:\n    \"\"\"\n    Perform parameter identifiability analysis.\n\n    Checks for parameter correlations and information content in the data.\n\n    Args:\n        parameters (Dict[str, float]): Parameter set to analyze.\n        measurements (MeasurementData): Data window for simulation.\n\n    Returns:\n        IdentifiabilityResult: Analysis results including correlation matrix.\n    \"\"\"\n    return self.identifiability_analyzer.analyze(parameters, measurements)\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.InitialCalibrator.sensitivity_analysis","title":"<code>sensitivity_analysis(parameters, measurements, objectives=None)</code>","text":"<p>Perform local sensitivity analysis for given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Dict[str, float]</code> <p>Parameter set to analyze.</p> required <code>measurements</code> <code>MeasurementData</code> <p>Data window for simulation.</p> required <code>objectives</code> <code>Optional[List[str]]</code> <p>List of objective variables.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, SensitivityResult]</code> <p>Dict[str, SensitivityResult]: Mapping of parameter names to sensitivity indices.</p> Source code in <code>pyadm1ode_calibration/calibration/methods/initial.py</code> <pre><code>def sensitivity_analysis(\n    self, parameters: Dict[str, float], measurements: MeasurementData, objectives: Optional[List[str]] = None\n) -&gt; Dict[str, SensitivityResult]:\n    \"\"\"\n    Perform local sensitivity analysis for given parameters.\n\n    Args:\n        parameters (Dict[str, float]): Parameter set to analyze.\n        measurements (MeasurementData): Data window for simulation.\n        objectives (Optional[List[str]]): List of objective variables.\n\n    Returns:\n        Dict[str, SensitivityResult]: Mapping of parameter names to sensitivity indices.\n    \"\"\"\n    return self.sensitivity_analyzer.analyze(parameters, measurements, objectives)\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.OnlineCalibrator","title":"<code>pyadm1ode_calibration.calibration.OnlineCalibrator(plant, verbose=True, parameter_bounds=None)</code>","text":"<p>               Bases: <code>BaseCalibrator</code></p> <p>Online calibrator for real-time parameter adjustment.</p> <p>Performs fast, bounded re-calibration when model predictions deviate from measurements. It is optimized for speed and stability, ensuring that parameters do not drift too far from their physical meanings.</p> <p>Parameters:</p> Name Type Description Default <code>plant</code> <code>Any</code> <p>The PyADM1ODE plant model to calibrate.</p> required <code>verbose</code> <code>bool</code> <p>Whether to enable verbose logging. Defaults to True.</p> <code>True</code> <code>parameter_bounds</code> <code>Optional[ParameterBounds]</code> <p>Custom parameter bounds manager.</p> <code>None</code> Source code in <code>pyadm1ode_calibration/calibration/methods/online.py</code> <pre><code>def __init__(self, plant: Any, verbose: bool = True, parameter_bounds: Optional[ParameterBounds] = None):\n    super().__init__(plant, verbose)\n    self.parameter_bounds: ParameterBounds = parameter_bounds or create_default_bounds()\n    self.validator: CalibrationValidator = CalibrationValidator(plant, verbose=False)\n    self.trigger: OnlineCalibrationTrigger = OnlineCalibrationTrigger()\n    self.state: OnlineState = OnlineState()\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.OnlineCalibrator-functions","title":"Functions","text":""},{"location":"api/calibration/#pyadm1ode_calibration.calibration.OnlineCalibrator.apply_calibration","title":"<code>apply_calibration(result)</code>","text":"<p>Apply calibrated parameters to the underlying plant model.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>CalibrationResult</code> <p>The result containing new parameter values.</p> required Source code in <code>pyadm1ode_calibration/calibration/methods/online.py</code> <pre><code>def apply_calibration(self, result: CalibrationResult) -&gt; None:\n    \"\"\"\n    Apply calibrated parameters to the underlying plant model.\n\n    Args:\n        result (CalibrationResult): The result containing new parameter values.\n    \"\"\"\n    for component in self.plant.components.values():\n        if component.component_type.value == \"digester\":\n            component.apply_calibration_parameters(result.parameters)\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.OnlineCalibrator.calibrate","title":"<code>calibrate(measurements, parameters=None, current_parameters=None, variance_threshold=0.15, max_parameter_change=0.2, time_window=7, method='nelder_mead', max_iterations=50, objectives=None, weights=None, use_constraints=True, **kwargs)</code>","text":"<p>Perform online re-calibration with bounded parameter adjustments.</p> <p>Parameters:</p> Name Type Description Default <code>measurements</code> <code>MeasurementData</code> <p>Recent measurement data window.</p> required <code>parameters</code> <code>Optional[List[str]]</code> <p>Parameters to adjust. If None, uses history.</p> <code>None</code> <code>current_parameters</code> <code>Optional[Dict[str, float]]</code> <p>Current values. If None, gets from plant.</p> <code>None</code> <code>variance_threshold</code> <code>float</code> <p>Variance threshold for triggering (0-1).</p> <code>0.15</code> <code>max_parameter_change</code> <code>float</code> <p>Max relative parameter change (0.0 to 1.0).</p> <code>0.2</code> <code>time_window</code> <code>int</code> <p>Number of days of recent data to use for optimization.</p> <code>7</code> <code>method</code> <code>str</code> <p>Optimization method name. Defaults to 'nelder_mead'.</p> <code>'nelder_mead'</code> <code>max_iterations</code> <code>int</code> <p>Maximum optimization iterations. Defaults to 50.</p> <code>50</code> <code>objectives</code> <code>Optional[List[str]]</code> <p>List of outputs to match (e.g., ['Q_ch4']).</p> <code>None</code> <code>weights</code> <code>Optional[Dict[str, float]]</code> <p>Objective weights for multi-objective cost.</p> <code>None</code> <code>use_constraints</code> <code>bool</code> <p>Whether to apply parameter box constraints.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Extra settings passed to the optimizer.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>CalibrationResult</code> <code>CalibrationResult</code> <p>Results of the online calibration step.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no parameters are specified and no history is available.</p> Source code in <code>pyadm1ode_calibration/calibration/methods/online.py</code> <pre><code>def calibrate(\n    self,\n    measurements: MeasurementData,\n    parameters: Optional[List[str]] = None,\n    current_parameters: Optional[Dict[str, float]] = None,\n    variance_threshold: float = 0.15,\n    max_parameter_change: float = 0.20,\n    time_window: int = 7,\n    method: str = \"nelder_mead\",\n    max_iterations: int = 50,\n    objectives: Optional[List[str]] = None,\n    weights: Optional[Dict[str, float]] = None,\n    use_constraints: bool = True,\n    **kwargs: Any,\n) -&gt; CalibrationResult:\n    \"\"\"\n    Perform online re-calibration with bounded parameter adjustments.\n\n    Args:\n        measurements (MeasurementData): Recent measurement data window.\n        parameters (Optional[List[str]]): Parameters to adjust. If None, uses history.\n        current_parameters (Optional[Dict[str, float]]): Current values. If None, gets from plant.\n        variance_threshold (float): Variance threshold for triggering (0-1).\n        max_parameter_change (float): Max relative parameter change (0.0 to 1.0).\n        time_window (int): Number of days of recent data to use for optimization.\n        method (str): Optimization method name. Defaults to 'nelder_mead'.\n        max_iterations (int): Maximum optimization iterations. Defaults to 50.\n        objectives (Optional[List[str]]): List of outputs to match (e.g., ['Q_ch4']).\n        weights (Optional[Dict[str, float]]): Objective weights for multi-objective cost.\n        use_constraints (bool): Whether to apply parameter box constraints.\n        **kwargs (Any): Extra settings passed to the optimizer.\n\n    Returns:\n        CalibrationResult: Results of the online calibration step.\n\n    Raises:\n        ValueError: If no parameters are specified and no history is available.\n    \"\"\"\n    start_time = time.time()\n    if objectives is None:\n        objectives = [\"Q_ch4\", \"pH\"]\n\n    if parameters is None:\n        if self.state.parameter_history:\n            parameters = list(self.state.parameter_history[-1].parameters.keys())\n        else:\n            raise ValueError(\"No parameters specified and no calibration history available\")\n\n    if current_parameters is None:\n        current_parameters = self._get_current_parameters()\n\n    windowed_data = self._extract_time_window(measurements, time_window)\n    current_variance = self._calculate_prediction_variance(windowed_data, current_parameters, objectives)\n    self.state.current_variance = current_variance\n\n    param_bounds = self._setup_online_bounds(parameters, current_parameters, max_parameter_change)\n\n    def simulator_wrapper(params: Dict[str, float]) -&gt; Dict[str, np.ndarray]:\n        return self.simulator.simulate_with_parameters(params, windowed_data)\n\n    measurements_dict: Dict[str, np.ndarray] = {\n        obj: windowed_data.get_measurement(obj).values for obj in objectives if obj in windowed_data.data.columns\n    }\n\n    objective_func: Callable[[np.ndarray], float] = MultiObjectiveFunction(\n        simulator=simulator_wrapper,\n        measurements_dict=measurements_dict,\n        objectives=objectives,\n        weights=weights or {obj: 1.0 / len(objectives) for obj in objectives},\n        parameter_names=parameters,\n        error_metric=\"rmse\",\n        normalize=True,\n    )\n\n    obj_func_final: Callable[[np.ndarray], float]\n    if use_constraints:\n        constraints = ParameterConstraints()\n        for p, (lb, ub) in param_bounds.items():\n            constraints.add_box_constraint(p, lb, ub, hard=True)\n\n        def penalized_objective(x: np.ndarray) -&gt; float:\n            params = {name: val for name, val in zip(parameters, x)}\n            return objective_func(x) + constraints.calculate_penalty(params)\n\n        obj_func_final = penalized_objective\n    else:\n        obj_func_final = objective_func\n\n    optimizer = create_optimizer(\n        method=method, bounds=param_bounds, max_iterations=max_iterations, verbose=self.verbose, **kwargs\n    )\n\n    initial_guess = np.array(\n        [current_parameters.get(p, self.parameter_bounds.get_default_values([p])[p]) for p in parameters]\n    )\n    opt_result = optimizer.optimize(obj_func_final, initial_guess=initial_guess)\n\n    validation_metrics: Dict[str, float] = {}\n    if opt_result.success:\n        val_res = self.validator.validate(\n            parameters=opt_result.parameter_dict, measurements=windowed_data, objectives=objectives\n        )\n        validation_metrics = {f\"{obj}_{k}\": float(getattr(m, k)) for obj, m in val_res.items() for k in [\"rmse\", \"r2\"]}\n\n    self.state.total_calibrations += 1\n    self.state.last_calibration_time = datetime.now()\n\n    history_entry = ParameterChangeHistory(\n        timestamp=datetime.now(),\n        parameters=opt_result.parameter_dict.copy(),\n        trigger_reason=\"variance_threshold\" if current_variance &gt; variance_threshold else \"manual\",\n        objective_value=float(opt_result.fun),\n        variance=float(current_variance),\n        success=bool(opt_result.success),\n    )\n    self.state.parameter_history.append(history_entry)\n\n    return CalibrationResult(\n        success=opt_result.success,\n        parameters=opt_result.parameter_dict,\n        initial_parameters=current_parameters,\n        objective_value=float(opt_result.fun),\n        n_iterations=int(opt_result.nit),\n        execution_time=time.time() - start_time,\n        method=method,\n        message=str(getattr(opt_result, \"message\", \"Online calibration completed\")),\n        validation_metrics=validation_metrics,\n    )\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.OnlineCalibrator.should_recalibrate","title":"<code>should_recalibrate(recent_measurements, objectives=None)</code>","text":"<p>Check if re-calibration should be triggered based on prediction error.</p> <p>Parameters:</p> Name Type Description Default <code>recent_measurements</code> <code>MeasurementData</code> <p>Recent plant data.</p> required <code>objectives</code> <code>Optional[List[str]]</code> <p>Variables to monitor for error.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[bool, str]</code> <p>Tuple[bool, str]: (should_recalibrate, reason_string).</p> Source code in <code>pyadm1ode_calibration/calibration/methods/online.py</code> <pre><code>def should_recalibrate(\n    self, recent_measurements: MeasurementData, objectives: Optional[List[str]] = None\n) -&gt; Tuple[bool, str]:\n    \"\"\"\n    Check if re-calibration should be triggered based on prediction error.\n\n    Args:\n        recent_measurements (MeasurementData): Recent plant data.\n        objectives (Optional[List[str]]): Variables to monitor for error.\n\n    Returns:\n        Tuple[bool, str]: (should_recalibrate, reason_string).\n    \"\"\"\n    if not self.trigger.enabled:\n        return False, \"Disabled\"\n\n    if objectives is None:\n        objectives = [\"Q_ch4\", \"pH\"]\n\n    if self.state.last_calibration_time:\n        hours = (datetime.now() - self.state.last_calibration_time).total_seconds() / 3600\n        if hours &lt; self.trigger.time_threshold:\n            return False, f\"Too soon since last calibration ({hours:.1f}h)\"\n\n    variance = self._calculate_prediction_variance(recent_measurements, self._get_current_parameters(), objectives)\n    self.state.current_variance = variance\n\n    if variance &gt; self.trigger.variance_threshold:\n        self.state.consecutive_violations += 1\n        if self.state.consecutive_violations &gt;= self.trigger.consecutive_violations:\n            return True, f\"Variance {variance:.4f} &gt; {self.trigger.variance_threshold}\"\n    else:\n        self.state.consecutive_violations = 0\n\n    return False, \"Prediction within accuracy threshold\"\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.ParameterBounds","title":"<code>pyadm1ode_calibration.calibration.ParameterBounds()</code>","text":"<p>Manager for parameter bounds in ADM1 calibration.</p> <p>Provides methods for accessing bounds, validating parameters, and calculating penalties for constraint violations.</p> <p>Attributes:</p> Name Type Description <code>bounds</code> <code>Dict[str, ParameterBound]</code> <p>Dictionary mapping parameter names to ParameterBound objects</p> Example <p>bounds = ParameterBounds() bounds.add_bound(\"k_dis\", lower=0.3, upper=0.8, default=0.5) is_valid = bounds.is_within_bounds(\"k_dis\", 0.6)</p> <p>Initialize empty parameter bounds manager.</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize empty parameter bounds manager.\"\"\"\n    self.bounds: Dict[str, ParameterBound] = {}\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.ParameterBounds-functions","title":"Functions","text":""},{"location":"api/calibration/#pyadm1ode_calibration.calibration.ParameterBounds.add_bound","title":"<code>add_bound(name, lower, upper, default, bound_type=BoundType.HARD, penalty_weight=1.0, description='', unit='', substrate_dependent=False)</code>","text":"<p>Add parameter bound.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <code>lower</code> <code>float</code> <p>Lower bound</p> required <code>upper</code> <code>float</code> <p>Upper bound</p> required <code>default</code> <code>float</code> <p>Default value</p> required <code>bound_type</code> <code>BoundType</code> <p>Type of bound</p> <code>HARD</code> <code>penalty_weight</code> <code>float</code> <p>Penalty weight for soft constraints</p> <code>1.0</code> <code>description</code> <code>str</code> <p>Parameter description</p> <code>''</code> <code>unit</code> <code>str</code> <p>Parameter unit</p> <code>''</code> <code>substrate_dependent</code> <code>bool</code> <p>Whether bound varies by substrate</p> <code>False</code> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def add_bound(\n    self,\n    name: str,\n    lower: float,\n    upper: float,\n    default: float,\n    bound_type: BoundType = BoundType.HARD,\n    penalty_weight: float = 1.0,\n    description: str = \"\",\n    unit: str = \"\",\n    substrate_dependent: bool = False,\n) -&gt; None:\n    \"\"\"\n    Add parameter bound.\n\n    Args:\n        name: Parameter name\n        lower: Lower bound\n        upper: Upper bound\n        default: Default value\n        bound_type: Type of bound\n        penalty_weight: Penalty weight for soft constraints\n        description: Parameter description\n        unit: Parameter unit\n        substrate_dependent: Whether bound varies by substrate\n    \"\"\"\n    self.bounds[name] = ParameterBound(\n        name=name,\n        lower=lower,\n        upper=upper,\n        default=default,\n        bound_type=bound_type,\n        penalty_weight=penalty_weight,\n        description=description,\n        unit=unit,\n        substrate_dependent=substrate_dependent,\n    )\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.ParameterBounds.calculate_penalty","title":"<code>calculate_penalty(name, value, penalty_type='quadratic')</code>","text":"<p>Calculate penalty for parameter value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <code>value</code> <code>float</code> <p>Parameter value</p> required <code>penalty_type</code> <code>str</code> <p>Type of penalty function</p> <code>'quadratic'</code> <p>Returns:</p> Type Description <code>float</code> <p>Penalty value</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def calculate_penalty(self, name: str, value: float, penalty_type: str = \"quadratic\") -&gt; float:\n    \"\"\"\n    Calculate penalty for parameter value.\n\n    Args:\n        name: Parameter name\n        value: Parameter value\n        penalty_type: Type of penalty function\n\n    Returns:\n        Penalty value\n    \"\"\"\n    bound = self.get_bounds(name)\n    if bound is None:\n        return 0.0\n    return bound.calculate_penalty(value, penalty_type)\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.ParameterBounds.calculate_total_penalty","title":"<code>calculate_total_penalty(parameters, penalty_type='quadratic')</code>","text":"<p>Calculate total penalty for all parameters.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Dict[str, float]</code> <p>Dictionary of parameter values</p> required <code>penalty_type</code> <code>str</code> <p>Type of penalty function</p> <code>'quadratic'</code> <p>Returns:</p> Type Description <code>float</code> <p>Total penalty</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def calculate_total_penalty(self, parameters: Dict[str, float], penalty_type: str = \"quadratic\") -&gt; float:\n    \"\"\"\n    Calculate total penalty for all parameters.\n\n    Args:\n        parameters: Dictionary of parameter values\n        penalty_type: Type of penalty function\n\n    Returns:\n        Total penalty\n    \"\"\"\n    total_penalty = 0.0\n    for name, value in parameters.items():\n        penalty = self.calculate_penalty(name, value, penalty_type)\n        if np.isinf(penalty):\n            return np.inf\n        total_penalty += penalty\n    return total_penalty\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.ParameterBounds.clip_to_bounds","title":"<code>clip_to_bounds(name, value)</code>","text":"<p>Clip parameter value to bounds.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <code>value</code> <code>float</code> <p>Parameter value</p> required <p>Returns:</p> Type Description <code>float</code> <p>Clipped value</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def clip_to_bounds(self, name: str, value: float) -&gt; float:\n    \"\"\"\n    Clip parameter value to bounds.\n\n    Args:\n        name: Parameter name\n        value: Parameter value\n\n    Returns:\n        Clipped value\n    \"\"\"\n    bound = self.get_bounds(name)\n    if bound is None:\n        return value\n    return bound.clip_to_bounds(value)\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.ParameterBounds.get_bounds","title":"<code>get_bounds(name)</code>","text":"<p>Get bounds for parameter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <p>Returns:</p> Type Description <code>Optional[ParameterBound]</code> <p>ParameterBound object or None if not found</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def get_bounds(self, name: str) -&gt; Optional[ParameterBound]:\n    \"\"\"\n    Get bounds for parameter.\n\n    Args:\n        name: Parameter name\n\n    Returns:\n        ParameterBound object or None if not found\n    \"\"\"\n    return self.bounds.get(name)\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.ParameterBounds.get_bounds_tuple","title":"<code>get_bounds_tuple(name)</code>","text":"<p>Get bounds as tuple (lower, upper).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <p>Returns:</p> Type Description <code>Optional[Tuple[float, float]]</code> <p>Tuple of (lower, upper) or None</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def get_bounds_tuple(self, name: str) -&gt; Optional[Tuple[float, float]]:\n    \"\"\"\n    Get bounds as tuple (lower, upper).\n\n    Args:\n        name: Parameter name\n\n    Returns:\n        Tuple of (lower, upper) or None\n    \"\"\"\n    bound = self.get_bounds(name)\n    if bound is None:\n        return None\n    return (bound.lower, bound.upper)\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.ParameterBounds.get_default_values","title":"<code>get_default_values(parameter_names)</code>","text":"<p>Get default values for parameters.</p> <p>Parameters:</p> Name Type Description Default <code>parameter_names</code> <code>List[str]</code> <p>List of parameter names</p> required <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dictionary of default values</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def get_default_values(self, parameter_names: List[str]) -&gt; Dict[str, float]:\n    \"\"\"\n    Get default values for parameters.\n\n    Args:\n        parameter_names: List of parameter names\n\n    Returns:\n        Dictionary of default values\n    \"\"\"\n    defaults = {}\n    for name in parameter_names:\n        bound = self.get_bounds(name)\n        if bound is not None:\n            defaults[name] = bound.default\n    return defaults\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.ParameterBounds.is_within_bounds","title":"<code>is_within_bounds(name, value, tolerance=0.0)</code>","text":"<p>Check if parameter value is within bounds.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <code>value</code> <code>float</code> <p>Parameter value</p> required <code>tolerance</code> <code>float</code> <p>Tolerance for boundary</p> <code>0.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if within bounds, False otherwise</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def is_within_bounds(self, name: str, value: float, tolerance: float = 0.0) -&gt; bool:\n    \"\"\"\n    Check if parameter value is within bounds.\n\n    Args:\n        name: Parameter name\n        value: Parameter value\n        tolerance: Tolerance for boundary\n\n    Returns:\n        True if within bounds, False otherwise\n    \"\"\"\n    bound = self.get_bounds(name)\n    if bound is None:\n        return True  # No bounds defined, assume valid\n    return bound.is_within_bounds(value, tolerance)\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.ParameterBounds.scale_to_unit_interval","title":"<code>scale_to_unit_interval(name, value)</code>","text":"<p>Scale parameter value to unit interval [0, 1].</p> <p>Useful for optimization algorithms that work better with normalized parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <code>value</code> <code>float</code> <p>Parameter value</p> required <p>Returns:</p> Type Description <code>float</code> <p>Scaled value in [0, 1]</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def scale_to_unit_interval(self, name: str, value: float) -&gt; float:\n    \"\"\"\n    Scale parameter value to unit interval [0, 1].\n\n    Useful for optimization algorithms that work better with\n    normalized parameters.\n\n    Args:\n        name: Parameter name\n        value: Parameter value\n\n    Returns:\n        Scaled value in [0, 1]\n    \"\"\"\n    bound = self.get_bounds(name)\n    if bound is None:\n        return value\n\n    if bound.upper == bound.lower:\n        return 0.5\n\n    return (value - bound.lower) / (bound.upper - bound.lower)\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.ParameterBounds.unscale_from_unit_interval","title":"<code>unscale_from_unit_interval(name, scaled_value)</code>","text":"<p>Unscale parameter value from unit interval [0, 1].</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter name</p> required <code>scaled_value</code> <code>float</code> <p>Scaled value in [0, 1]</p> required <p>Returns:</p> Type Description <code>float</code> <p>Unscaled parameter value</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def unscale_from_unit_interval(self, name: str, scaled_value: float) -&gt; float:\n    \"\"\"\n    Unscale parameter value from unit interval [0, 1].\n\n    Args:\n        name: Parameter name\n        scaled_value: Scaled value in [0, 1]\n\n    Returns:\n        Unscaled parameter value\n    \"\"\"\n    bound = self.get_bounds(name)\n    if bound is None:\n        return scaled_value\n\n    return bound.lower + scaled_value * (bound.upper - bound.lower)\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.ParameterBounds.validate_parameters","title":"<code>validate_parameters(parameters, raise_on_invalid=False)</code>","text":"<p>Validate all parameters against bounds.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Dict[str, float]</code> <p>Dictionary of parameter values</p> required <code>raise_on_invalid</code> <code>bool</code> <p>Raise exception if invalid</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[bool, List[str]]</code> <p>Tuple of (all_valid, list of error messages)</p> Source code in <code>pyadm1ode_calibration/calibration/parameter_bounds.py</code> <pre><code>def validate_parameters(self, parameters: Dict[str, float], raise_on_invalid: bool = False) -&gt; Tuple[bool, List[str]]:\n    \"\"\"\n    Validate all parameters against bounds.\n\n    Args:\n        parameters: Dictionary of parameter values\n        raise_on_invalid: Raise exception if invalid\n\n    Returns:\n        Tuple of (all_valid, list of error messages)\n    \"\"\"\n    errors = []\n\n    for name, value in parameters.items():\n        bound = self.get_bounds(name)\n        if bound is None:\n            continue\n\n        if not bound.is_within_bounds(value):\n            error = f\"Parameter '{name}' = {value:.4f} is outside bounds [{bound.lower:.4f}, {bound.upper:.4f}]\"\n            errors.append(error)\n\n    if errors and raise_on_invalid:\n        raise ValueError(\"\\n\".join(errors))\n\n    return (len(errors) == 0, errors)\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.CalibrationValidator","title":"<code>pyadm1ode_calibration.calibration.CalibrationValidator(plant, verbose=True)</code>","text":"<p>Validator for calibrated model parameters.</p> <p>Provides methods to evaluate the goodness-of-fit of calibrated parameters on both training and out-of-sample validation data.</p> <p>Parameters:</p> Name Type Description Default <code>plant</code> <code>Any</code> <p>The PyADM1ODE plant model instance.</p> required <code>verbose</code> <code>bool</code> <p>Whether to enable verbose output. Defaults to True.</p> <code>True</code> Source code in <code>pyadm1ode_calibration/calibration/validation.py</code> <pre><code>def __init__(self, plant: Any, verbose: bool = True):\n    self.plant = plant\n    self.verbose = verbose\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.CalibrationValidator-functions","title":"Functions","text":""},{"location":"api/calibration/#pyadm1ode_calibration.calibration.CalibrationValidator.analyze_residuals","title":"<code>analyze_residuals(measurements, simulated, objectives=None)</code>","text":"<p>Perform detailed residual analysis.</p> <p>Parameters:</p> Name Type Description Default <code>measurements</code> <code>MeasurementData</code> <p>Reference measurements.</p> required <code>simulated</code> <code>Dict[str, ndarray]</code> <p>Simulated outputs.</p> required <code>objectives</code> <code>Optional[List[str]]</code> <p>Variables to analyze.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, ResidualAnalysis]</code> <p>Dict[str, ResidualAnalysis]: Analysis results for each objective.</p> Source code in <code>pyadm1ode_calibration/calibration/validation.py</code> <pre><code>def analyze_residuals(\n    self,\n    measurements: MeasurementData,\n    simulated: Dict[str, np.ndarray],\n    objectives: Optional[List[str]] = None,\n) -&gt; Dict[str, ResidualAnalysis]:\n    \"\"\"\n    Perform detailed residual analysis.\n\n    Args:\n        measurements (MeasurementData): Reference measurements.\n        simulated (Dict[str, np.ndarray]): Simulated outputs.\n        objectives (Optional[List[str]]): Variables to analyze.\n\n    Returns:\n        Dict[str, ResidualAnalysis]: Analysis results for each objective.\n    \"\"\"\n    if objectives is None:\n        objectives = list(simulated.keys())\n\n    results = {}\n    for objective in objectives:\n        if objective not in simulated:\n            continue\n\n        observed = self._extract_measurements(measurements, objective)\n        predicted = simulated[objective]\n\n        observed, predicted = self._align_arrays(observed, predicted)\n\n        if len(observed) &lt; 3:\n            continue\n\n        residuals = observed - predicted\n        std_residuals = self._standardize_residuals(residuals)\n        normality = self._test_normality(residuals)\n        autocorr = self._calculate_autocorrelation(residuals)\n        hetero = self._test_heteroscedasticity(residuals, predicted)\n        outliers = np.where(np.abs(std_residuals) &gt; 3)[0].tolist()\n\n        results[objective] = ResidualAnalysis(\n            objective=objective,\n            residuals=residuals,\n            standardized_residuals=std_residuals,\n            normality_test=normality,\n            autocorrelation=autocorr,\n            heteroscedasticity_test=hetero,\n            outlier_indices=outliers,\n        )\n\n    return results\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.CalibrationValidator.cross_validate","title":"<code>cross_validate(parameters, measurements, n_folds=5, objectives=None)</code>","text":"<p>Perform k-fold cross-validation.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Dict[str, float]</code> <p>Calibrated parameters.</p> required <code>measurements</code> <code>MeasurementData</code> <p>Full dataset to split.</p> required <code>n_folds</code> <code>int</code> <p>Number of folds. Defaults to 5.</p> <code>5</code> <code>objectives</code> <code>Optional[List[str]]</code> <p>Variables to validate.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, List[ValidationMetrics]]</code> <p>Dict[str, List[ValidationMetrics]]: List of metrics for each fold.</p> Source code in <code>pyadm1ode_calibration/calibration/validation.py</code> <pre><code>def cross_validate(\n    self,\n    parameters: Dict[str, float],\n    measurements: MeasurementData,\n    n_folds: int = 5,\n    objectives: Optional[List[str]] = None,\n) -&gt; Dict[str, List[ValidationMetrics]]:\n    \"\"\"\n    Perform k-fold cross-validation.\n\n    Args:\n        parameters (Dict[str, float]): Calibrated parameters.\n        measurements (MeasurementData): Full dataset to split.\n        n_folds (int): Number of folds. Defaults to 5.\n        objectives (Optional[List[str]]): Variables to validate.\n\n    Returns:\n        Dict[str, List[ValidationMetrics]]: List of metrics for each fold.\n    \"\"\"\n    if objectives is None:\n        objectives = [\"Q_ch4\", \"pH\", \"VFA\"]\n\n    n_samples = len(measurements)\n    fold_size = n_samples // n_folds\n    cv_results: Dict[str, List[ValidationMetrics]] = {obj: [] for obj in objectives}\n\n    for fold in range(n_folds):\n        start_idx = fold * fold_size\n        end_idx = start_idx + fold_size if fold &lt; n_folds - 1 else n_samples\n\n        val_data = measurements.data.iloc[start_idx:end_idx].copy()\n        val_measurements = type(measurements)(val_data)\n\n        fold_metrics = self.validate(parameters, val_measurements, objectives)\n        for obj, metrics in fold_metrics.items():\n            cv_results[obj].append(metrics)\n\n    return cv_results\n</code></pre>"},{"location":"api/calibration/#pyadm1ode_calibration.calibration.CalibrationValidator.validate","title":"<code>validate(parameters, measurements, objectives=None, simulation_duration=None)</code>","text":"<p>Validate parameters against measurement data.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Dict[str, float]</code> <p>Calibrated parameters to test.</p> required <code>measurements</code> <code>MeasurementData</code> <p>Reference measurement data.</p> required <code>objectives</code> <code>Optional[List[str]]</code> <p>Variables to validate.</p> <code>None</code> <code>simulation_duration</code> <code>Optional[float]</code> <p>Duration in days.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, ValidationMetrics]</code> <p>Dict[str, ValidationMetrics]: Metrics for each objective.</p> Source code in <code>pyadm1ode_calibration/calibration/validation.py</code> <pre><code>def validate(\n    self,\n    parameters: Dict[str, float],\n    measurements: MeasurementData,\n    objectives: Optional[List[str]] = None,\n    simulation_duration: Optional[float] = None,\n) -&gt; Dict[str, ValidationMetrics]:\n    \"\"\"\n    Validate parameters against measurement data.\n\n    Args:\n        parameters (Dict[str, float]): Calibrated parameters to test.\n        measurements (MeasurementData): Reference measurement data.\n        objectives (Optional[List[str]]): Variables to validate.\n        simulation_duration (Optional[float]): Duration in days.\n\n    Returns:\n        Dict[str, ValidationMetrics]: Metrics for each objective.\n    \"\"\"\n    if objectives is None:\n        objectives = [\"Q_ch4\", \"pH\", \"VFA\"]\n\n    self._apply_parameters(parameters)\n\n    if simulation_duration is None:\n        simulation_duration = len(measurements) * (1.0 / 24.0)\n\n    simulated_outputs = self._simulate_plant(measurements, simulation_duration)\n\n    metrics = {}\n    for objective in objectives:\n        if objective not in simulated_outputs:\n            warnings.warn(f\"Objective '{objective}' not in simulation outputs\")\n            continue\n\n        observed = self._extract_measurements(measurements, objective)\n        predicted = simulated_outputs[objective]\n\n        observed, predicted = self._align_arrays(observed, predicted)\n\n        if len(observed) == 0:\n            warnings.warn(f\"No valid data for objective '{objective}'\")\n            continue\n\n        obj_metrics = self._calculate_metrics(objective, observed, predicted)\n        metrics[objective] = obj_metrics\n\n    return metrics\n</code></pre>"},{"location":"api/io/","title":"IO API","text":""},{"location":"api/io/#pyadm1ode_calibration.io.MeasurementData","title":"<code>pyadm1ode_calibration.io.MeasurementData(data, metadata=None)</code>","text":"<p>Container for biogas plant measurement data.</p> <p>This class manages time-series data from biogas plants, providing methods for loading, validation, cleaning (outlier removal), and pre-processing (gap filling, resampling).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame containing measurements. If a 'timestamp' column exists, it will be converted to datetime and used as the index.</p> required <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary containing contextual information (e.g., plant ID, location).</p> <code>None</code> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def __init__(self, data: pd.DataFrame, metadata: Optional[Dict[str, Any]] = None):\n    self.data = data\n    self.metadata = metadata or {}\n\n    if \"timestamp\" in self.data.columns:\n        if not pd.api.types.is_datetime64_any_dtype(self.data[\"timestamp\"]):\n            self.data[\"timestamp\"] = pd.to_datetime(self.data[\"timestamp\"])\n        self.data = self.data.set_index(\"timestamp\").sort_index()\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.MeasurementData-functions","title":"Functions","text":""},{"location":"api/io/#pyadm1ode_calibration.io.MeasurementData.fill_gaps","title":"<code>fill_gaps(columns=None, method='interpolate', **kwargs)</code>","text":"<p>Fill missing values (NaNs) in the data.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Optional[List[str]]</code> <p>Columns to fill.</p> <code>None</code> <code>method</code> <code>str</code> <p>Fill method ('interpolate', 'forward', 'backward', 'mean', 'median').</p> <code>'interpolate'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for filling (e.g., 'limit').</p> <code>{}</code> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def fill_gaps(self, columns: Optional[List[str]] = None, method: str = \"interpolate\", **kwargs: Any) -&gt; None:\n    \"\"\"\n    Fill missing values (NaNs) in the data.\n\n    Args:\n        columns (Optional[List[str]]): Columns to fill.\n        method (str): Fill method ('interpolate', 'forward', 'backward', 'mean', 'median').\n        **kwargs (Any): Additional arguments for filling (e.g., 'limit').\n    \"\"\"\n    if columns is None:\n        columns = self.data.columns.tolist()\n\n    for col in columns:\n        if col not in self.data.columns:\n            continue\n        if method == \"interpolate\":\n            limit = kwargs.get(\"limit\", None)\n            self.data[col] = self.data[col].interpolate(method=\"linear\", limit=limit)\n        elif method == \"forward\":\n            limit = kwargs.get(\"limit\", None)\n            self.data[col] = self.data[col].ffill(limit=limit)\n        elif method == \"backward\":\n            limit = kwargs.get(\"limit\", None)\n            self.data[col] = self.data[col].bfill(limit=limit)\n        elif method == \"mean\":\n            self.data[col] = self.data[col].fillna(self.data[col].mean())\n        elif method == \"median\":\n            self.data[col] = self.data[col].fillna(self.data[col].median())\n        else:\n            raise ValueError(f\"Unknown fill method: {method}\")\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.MeasurementData.from_csv","title":"<code>from_csv(filepath, timestamp_column='timestamp', sep=',', parse_dates=True, resample=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load measurement data from a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the CSV file.</p> required <code>timestamp_column</code> <code>str</code> <p>Name of the column containing time information.</p> <code>'timestamp'</code> <code>sep</code> <code>str</code> <p>CSV delimiter. Defaults to ','.</p> <code>','</code> <code>parse_dates</code> <code>bool</code> <p>Whether to parse dates. Defaults to True.</p> <code>True</code> <code>resample</code> <code>Optional[str]</code> <p>Frequency string to resample to (e.g., '1h').</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to pd.read_csv.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>MeasurementData</code> <code>MeasurementData</code> <p>A new instance with the loaded data.</p> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>@classmethod\ndef from_csv(\n    cls,\n    filepath: str,\n    timestamp_column: str = \"timestamp\",\n    sep: str = \",\",\n    parse_dates: bool = True,\n    resample: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; \"MeasurementData\":\n    \"\"\"\n    Load measurement data from a CSV file.\n\n    Args:\n        filepath (str): Path to the CSV file.\n        timestamp_column (str): Name of the column containing time information.\n        sep (str): CSV delimiter. Defaults to ','.\n        parse_dates (bool): Whether to parse dates. Defaults to True.\n        resample (Optional[str]): Frequency string to resample to (e.g., '1h').\n        **kwargs (Any): Additional arguments passed to pd.read_csv.\n\n    Returns:\n        MeasurementData: A new instance with the loaded data.\n    \"\"\"\n    data = pd.read_csv(filepath, sep=sep, **kwargs)\n    if timestamp_column in data.columns:\n        data[\"timestamp\"] = pd.to_datetime(data[timestamp_column])\n        if timestamp_column != \"timestamp\":\n            data = data.drop(columns=[timestamp_column])\n    instance = cls(data)\n    if resample is not None:\n        instance.resample(resample)\n    return instance\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.MeasurementData.get_measurement","title":"<code>get_measurement(column, start_time=None, end_time=None)</code>","text":"<p>Get a specific measurement series, optionally windowed.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Name of the measurement column.</p> required <code>start_time</code> <code>Optional[datetime]</code> <p>Start of window.</p> <code>None</code> <code>end_time</code> <code>Optional[datetime]</code> <p>End of window.</p> <code>None</code> <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: The requested time series.</p> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def get_measurement(\n    self, column: str, start_time: Optional[Union[str, datetime]] = None, end_time: Optional[Union[str, datetime]] = None\n) -&gt; pd.Series:\n    \"\"\"\n    Get a specific measurement series, optionally windowed.\n\n    Args:\n        column (str): Name of the measurement column.\n        start_time (Optional[datetime]): Start of window.\n        end_time (Optional[datetime]): End of window.\n\n    Returns:\n        pd.Series: The requested time series.\n    \"\"\"\n    if column not in self.data.columns:\n        raise ValueError(f\"Column '{column}' not found\")\n    series = self.data[column]\n    if start_time is not None or end_time is not None:\n        series = series.loc[start_time:end_time]  # type: ignore\n    return series\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.MeasurementData.get_substrate_feeds","title":"<code>get_substrate_feeds(substrate_columns=None)</code>","text":"<p>Extract substrate feed rates as a 2D numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>substrate_columns</code> <code>Optional[List[str]]</code> <p>Column names for substrates.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Matrix of feed rates.</p> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def get_substrate_feeds(self, substrate_columns: Optional[List[str]] = None) -&gt; np.ndarray:\n    \"\"\"\n    Extract substrate feed rates as a 2D numpy array.\n\n    Args:\n        substrate_columns (Optional[List[str]]): Column names for substrates.\n\n    Returns:\n        np.ndarray: Matrix of feed rates.\n    \"\"\"\n    if substrate_columns is None:\n        substrate_columns = [col for col in self.data.columns if col.startswith(\"Q_sub\")]\n    if not substrate_columns:\n        raise ValueError(\"No substrate columns found\")\n    return self.data[substrate_columns].values\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.MeasurementData.get_time_window","title":"<code>get_time_window(start_time, end_time)</code>","text":"<p>Create a new MeasurementData instance for a specific time window.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>Union[str, datetime]</code> <p>Start timestamp.</p> required <code>end_time</code> <code>Union[str, datetime]</code> <p>End timestamp.</p> required <p>Returns:</p> Name Type Description <code>MeasurementData</code> <code>MeasurementData</code> <p>A subset of the data.</p> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def get_time_window(self, start_time: Union[str, datetime], end_time: Union[str, datetime]) -&gt; \"MeasurementData\":\n    \"\"\"\n    Create a new MeasurementData instance for a specific time window.\n\n    Args:\n        start_time (Union[str, datetime]): Start timestamp.\n        end_time (Union[str, datetime]): End timestamp.\n\n    Returns:\n        MeasurementData: A subset of the data.\n    \"\"\"\n    windowed_data = self.data.loc[start_time:end_time].copy()  # type: ignore\n    return MeasurementData(windowed_data, metadata=self.metadata.copy())\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.MeasurementData.remove_outliers","title":"<code>remove_outliers(columns=None, method='zscore', threshold=3.0, **kwargs)</code>","text":"<p>Detect and remove outliers from specified columns.</p> <p>Outliers are replaced with NaN.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Optional[List[str]]</code> <p>Columns to check. Defaults to all numeric.</p> <code>None</code> <code>method</code> <code>str</code> <p>Detection method ('zscore', 'iqr', 'moving_window').</p> <code>'zscore'</code> <code>threshold</code> <code>float</code> <p>Threshold for outlier detection.</p> <code>3.0</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the detection method.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Total number of outliers removed.</p> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def remove_outliers(\n    self, columns: Optional[List[str]] = None, method: str = \"zscore\", threshold: float = 3.0, **kwargs: Any\n) -&gt; int:\n    \"\"\"\n    Detect and remove outliers from specified columns.\n\n    Outliers are replaced with NaN.\n\n    Args:\n        columns (Optional[List[str]]): Columns to check. Defaults to all numeric.\n        method (str): Detection method ('zscore', 'iqr', 'moving_window').\n        threshold (float): Threshold for outlier detection.\n        **kwargs (Any): Additional arguments for the detection method.\n\n    Returns:\n        int: Total number of outliers removed.\n    \"\"\"\n    if columns is None:\n        columns = self.data.select_dtypes(include=[np.number]).columns.tolist()\n\n    n_outliers = 0\n    for col in columns:\n        if col not in self.data.columns:\n            continue\n        if method == \"zscore\":\n            is_outlier = OutlierDetector.detect_zscore(self.data[col], threshold=threshold)\n        elif method == \"iqr\":\n            is_outlier = OutlierDetector.detect_iqr(self.data[col], multiplier=threshold)\n        elif method == \"moving_window\":\n            window = kwargs.get(\"window\", 5)\n            is_outlier = OutlierDetector.detect_moving_window(self.data[col], window=window, threshold=threshold)\n        else:\n            raise ValueError(f\"Unknown outlier detection method: {method}\")\n\n        n_col_outliers = int(is_outlier.sum())\n        self.data.loc[is_outlier, col] = np.nan\n        n_outliers += n_col_outliers\n    return n_outliers\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.MeasurementData.resample","title":"<code>resample(freq, aggregation='mean')</code>","text":"<p>Resample the time series data to a new frequency.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>str</code> <p>Frequency string (e.g., '1h', '1d').</p> required <code>aggregation</code> <code>str</code> <p>Aggregation function ('mean', 'sum', 'first', 'last').</p> <code>'mean'</code> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def resample(self, freq: str, aggregation: str = \"mean\") -&gt; None:\n    \"\"\"\n    Resample the time series data to a new frequency.\n\n    Args:\n        freq (str): Frequency string (e.g., '1h', '1d').\n        aggregation (str): Aggregation function ('mean', 'sum', 'first', 'last').\n    \"\"\"\n    resampler = self.data.resample(freq)\n    if aggregation == \"mean\":\n        self.data = resampler.mean()\n    elif aggregation == \"sum\":\n        self.data = resampler.sum()\n    elif aggregation == \"first\":\n        self.data = resampler.first()\n    elif aggregation == \"last\":\n        self.data = resampler.last()\n    else:\n        raise ValueError(f\"Unknown aggregation method: {aggregation}\")\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.MeasurementData.summary","title":"<code>summary()</code>","text":"<p>Get a statistical summary of all measurement columns.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Descriptive statistics.</p> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def summary(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Get a statistical summary of all measurement columns.\n\n    Returns:\n        pd.DataFrame: Descriptive statistics.\n    \"\"\"\n    return self.data.describe()\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.MeasurementData.to_csv","title":"<code>to_csv(filepath, **kwargs)</code>","text":"<p>Save the current data to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Destination path.</p> required <code>**kwargs</code> <code>Any</code> <p>Passed to pd.DataFrame.to_csv.</p> <code>{}</code> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def to_csv(self, filepath: str, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Save the current data to a CSV file.\n\n    Args:\n        filepath (str): Destination path.\n        **kwargs (Any): Passed to pd.DataFrame.to_csv.\n    \"\"\"\n    self.data.to_csv(filepath, **kwargs)\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.MeasurementData.validate","title":"<code>validate(required_columns=None, expected_ranges=None)</code>","text":"<p>Validate measurement data against schema and range expectations.</p> <p>Parameters:</p> Name Type Description Default <code>required_columns</code> <code>Optional[List[str]]</code> <p>Columns that must be present.</p> <code>None</code> <code>expected_ranges</code> <code>Optional[Dict[str, Tuple[float, float]]]</code> <p>Mapping of column names to (min, max) range tuples.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ValidationResult</code> <code>ValidationResult</code> <p>Result of the validation checks.</p> Source code in <code>pyadm1ode_calibration/io/loaders/measurement_data.py</code> <pre><code>def validate(\n    self, required_columns: Optional[List[str]] = None, expected_ranges: Optional[Dict[str, Tuple[float, float]]] = None\n) -&gt; ValidationResult:\n    \"\"\"\n    Validate measurement data against schema and range expectations.\n\n    Args:\n        required_columns (Optional[List[str]]): Columns that must be present.\n        expected_ranges (Optional[Dict[str, Tuple[float, float]]]):\n            Mapping of column names to (min, max) range tuples.\n\n    Returns:\n        ValidationResult: Result of the validation checks.\n    \"\"\"\n    if expected_ranges is None:\n        expected_ranges = {\n            \"pH\": (5.0, 9.0),\n            \"VFA\": (0.0, 20.0),\n            \"TAC\": (0.0, 50.0),\n            \"Q_gas\": (0.0, 5000.0),\n            \"Q_ch4\": (0.0, 3000.0),\n            \"T_digester\": (273.15, 333.15),\n        }\n    return DataValidator.validate(self.data, required_columns=required_columns, expected_ranges=expected_ranges)\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.CSVHandler","title":"<code>pyadm1ode_calibration.io.CSVHandler(decimal_separator='.', thousands_separator=',')</code>","text":"<p>Handler for CSV file operations in PyADM1.</p> <p>Supports reading and writing various CSV formats used in biogas plant operation and laboratory analysis.</p> Example <p>handler = CSVHandler() data = handler.load_substrate_lab_data(\"lab_results.csv\")</p> <p>Initialize CSV handler.</p> <p>Parameters:</p> Name Type Description Default <code>decimal_separator</code> <code>str</code> <p>Decimal separator (\".\" or \",\")</p> <code>'.'</code> <code>thousands_separator</code> <code>str</code> <p>Thousands separator (\",\" or \".\" or \"\")</p> <code>','</code> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def __init__(self, decimal_separator: str = \".\", thousands_separator: str = \",\"):\n    \"\"\"\n    Initialize CSV handler.\n\n    Args:\n        decimal_separator: Decimal separator (\".\" or \",\")\n        thousands_separator: Thousands separator (\",\" or \".\" or \"\")\n    \"\"\"\n    self.decimal_separator = decimal_separator\n    self.thousands_separator = thousands_separator\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.CSVHandler-functions","title":"Functions","text":""},{"location":"api/io/#pyadm1ode_calibration.io.CSVHandler.create_template_substrate_csv","title":"<code>create_template_substrate_csv(filepath, format_type='horizontal')</code>","text":"<p>Create template CSV file for substrate data entry.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Output file path</p> required <code>format_type</code> <code>str</code> <p>\"horizontal\" or \"vertical\"</p> <code>'horizontal'</code> Example <p>handler.create_template_substrate_csv(\"template.csv\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def create_template_substrate_csv(self, filepath: str, format_type: str = \"horizontal\") -&gt; None:\n    \"\"\"\n    Create template CSV file for substrate data entry.\n\n    Args:\n        filepath: Output file path\n        format_type: \"horizontal\" or \"vertical\"\n\n    Example:\n        &gt;&gt;&gt; handler.create_template_substrate_csv(\"template.csv\")\n    \"\"\"\n    if format_type == \"horizontal\":\n        # One row per sample\n        template = pd.DataFrame(\n            columns=[\n                \"substrate_name\",\n                \"substrate_type\",\n                \"sample_date\",\n                \"TS\",\n                \"VS\",\n                \"oTS\",\n                \"foTS\",\n                \"RP\",\n                \"RL\",\n                \"RF\",\n                \"NDF\",\n                \"ADF\",\n                \"ADL\",\n                \"pH\",\n                \"NH4_N\",\n                \"TAC\",\n                \"COD_S\",\n                \"BMP\",\n                \"C_content\",\n                \"N_content\",\n                \"C_to_N\",\n            ]\n        )\n\n        # Add example row\n        template.loc[0] = [\n            \"Maize silage\",\n            \"maize\",\n            \"2024-01-15\",\n            32.5,\n            96.2,\n            31.3,\n            28.5,\n            8.5,\n            3.2,\n            21.5,\n            42.1,\n            22.3,\n            2.1,\n            3.9,\n            0.5,\n            11.0,\n            18.5,\n            345.0,\n            45.2,\n            1.8,\n            25.1,\n        ]\n\n    else:  # vertical\n        template = pd.DataFrame(\n            {\n                \"Parameter\": [\n                    \"Substrate name\",\n                    \"Substrate type\",\n                    \"TS\",\n                    \"VS\",\n                    \"RP\",\n                    \"RL\",\n                    \"NDF\",\n                    \"ADF\",\n                    \"ADL\",\n                    \"pH\",\n                    \"NH4-N\",\n                    \"TAC\",\n                    \"COD_S\",\n                    \"BMP\",\n                ],\n                \"Value\": [\"Maize silage\", \"maize\", 32.5, 96.2, 8.5, 3.2, 42.1, 22.3, 2.1, 3.9, 0.5, 11.0, 18.5, 345.0],\n                \"Unit\": [\n                    \"\",\n                    \"\",\n                    \"% FM\",\n                    \"% TS\",\n                    \"% TS\",\n                    \"% TS\",\n                    \"% TS\",\n                    \"% TS\",\n                    \"% TS\",\n                    \"-\",\n                    \"g/L\",\n                    \"mmol/L\",\n                    \"g/L\",\n                    \"L CH4/kg oTS\",\n                ],\n            }\n        )\n\n    template.to_csv(filepath, index=False)\n    print(f\"\u2713 Created template CSV at {filepath}\")\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.CSVHandler.export_measurement_data","title":"<code>export_measurement_data(data, filepath, sep=',', encoding='utf-8', include_index=True)</code>","text":"<p>Export measurement data to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame with measurements</p> required <code>filepath</code> <code>str</code> <p>Output file path</p> required <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <code>include_index</code> <code>bool</code> <p>Include index (timestamp) in output</p> <code>True</code> Example <p>handler.export_measurement_data(measurements, \"export.csv\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def export_measurement_data(\n    self, data: pd.DataFrame, filepath: str, sep: str = \",\", encoding: str = \"utf-8\", include_index: bool = True\n) -&gt; None:\n    \"\"\"\n    Export measurement data to CSV.\n\n    Args:\n        data: DataFrame with measurements\n        filepath: Output file path\n        sep: Column separator\n        encoding: File encoding\n        include_index: Include index (timestamp) in output\n\n    Example:\n        &gt;&gt;&gt; handler.export_measurement_data(measurements, \"export.csv\")\n    \"\"\"\n    data.to_csv(filepath, sep=sep, encoding=encoding, index=include_index)\n    print(f\"\u2713 Exported measurement data to {filepath} ({len(data)} rows)\")\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.CSVHandler.export_parameter_table","title":"<code>export_parameter_table(data, filepath, sep=',', encoding='utf-8')</code>","text":"<p>Export parameter table to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame with parameters</p> required <code>filepath</code> <code>str</code> <p>Output file path</p> required <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> Example <p>handler.export_parameter_table(params_df, \"parameters.csv\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def export_parameter_table(self, data: pd.DataFrame, filepath: str, sep: str = \",\", encoding: str = \"utf-8\") -&gt; None:\n    \"\"\"\n    Export parameter table to CSV.\n\n    Args:\n        data: DataFrame with parameters\n        filepath: Output file path\n        sep: Column separator\n        encoding: File encoding\n\n    Example:\n        &gt;&gt;&gt; handler.export_parameter_table(params_df, \"parameters.csv\")\n    \"\"\"\n    data.to_csv(filepath, sep=sep, encoding=encoding)\n    print(f\"\u2713 Exported parameter table to {filepath}\")\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.CSVHandler.export_simulation_results","title":"<code>export_simulation_results(results, filepath, sep=',', encoding='utf-8', flatten_components=True)</code>","text":"<p>Export simulation results to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>List[Dict[str, Any]]</code> <p>List of result dicts from plant.simulate()</p> required <code>filepath</code> <code>str</code> <p>Output file path</p> required <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <code>flatten_components</code> <code>bool</code> <p>Flatten component results into columns</p> <code>True</code> Example <p>results = plant.simulate(duration=30, dt=1/24) handler.export_simulation_results(results, \"simulation.csv\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def export_simulation_results(\n    self,\n    results: List[Dict[str, Any]],\n    filepath: str,\n    sep: str = \",\",\n    encoding: str = \"utf-8\",\n    flatten_components: bool = True,\n) -&gt; None:\n    \"\"\"\n    Export simulation results to CSV.\n\n    Args:\n        results: List of result dicts from plant.simulate()\n        filepath: Output file path\n        sep: Column separator\n        encoding: File encoding\n        flatten_components: Flatten component results into columns\n\n    Example:\n        &gt;&gt;&gt; results = plant.simulate(duration=30, dt=1/24)\n        &gt;&gt;&gt; handler.export_simulation_results(results, \"simulation.csv\")\n    \"\"\"\n    if not results:\n        warnings.warn(\"No results to export\")\n        return\n\n    # Convert to DataFrame\n    if flatten_components:\n        # Flatten structure: time, component1_metric1, component1_metric2, ...\n        rows = []\n        for result in results:\n            row = {\"time\": result[\"time\"]}\n\n            for comp_id, comp_data in result[\"components\"].items():\n                for metric, value in comp_data.items():\n                    # Skip nested dicts (like gas_storage)\n                    if isinstance(value, dict):\n                        continue\n                    col_name = f\"{comp_id}_{metric}\"\n                    row[col_name] = value\n\n            rows.append(row)\n\n        df = pd.DataFrame(rows)\n    else:\n        # Simple format: just time and first component's data\n        first_comp_id = list(results[0][\"components\"].keys())[0]\n        rows = []\n        for result in results:\n            row = {\"time\": result[\"time\"]}\n            row.update(result[\"components\"][first_comp_id])\n            # Remove nested dicts\n            row = {k: v for k, v in row.items() if not isinstance(v, dict)}\n            rows.append(row)\n\n        df = pd.DataFrame(rows)\n\n    # Export\n    df.to_csv(filepath, sep=sep, encoding=encoding, index=False)\n    print(f\"\u2713 Exported simulation results to {filepath} ({len(df)} time points)\")\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.CSVHandler.export_substrate_data","title":"<code>export_substrate_data(data, filepath, sep=',', encoding='utf-8')</code>","text":"<p>Export substrate data to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Dict[str, Any], DataFrame]</code> <p>Dict or DataFrame with substrate data</p> required <code>filepath</code> <code>str</code> <p>Output file path</p> required <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> Example <p>handler.export_substrate_data(substrate_data, \"export.csv\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def export_substrate_data(\n    self, data: Union[Dict[str, Any], pd.DataFrame], filepath: str, sep: str = \",\", encoding: str = \"utf-8\"\n) -&gt; None:\n    \"\"\"\n    Export substrate data to CSV.\n\n    Args:\n        data: Dict or DataFrame with substrate data\n        filepath: Output file path\n        sep: Column separator\n        encoding: File encoding\n\n    Example:\n        &gt;&gt;&gt; handler.export_substrate_data(substrate_data, \"export.csv\")\n    \"\"\"\n    if isinstance(data, dict):\n        df = pd.DataFrame([data])\n    else:\n        df = data\n\n    df.to_csv(filepath, sep=sep, encoding=encoding, index=False)\n    print(f\"\u2713 Exported substrate data to {filepath}\")\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.CSVHandler.load_measurement_data","title":"<code>load_measurement_data(filepath, timestamp_column='timestamp', sep=',', encoding='utf-8', parse_dates=True, resample=None)</code>","text":"<p>Load time series measurement data from CSV.</p> <p>Expected columns: - timestamp (or Zeit, Zeitstempel) - Q_sub_* (substrate feeds) - pH, VFA, TAC, FOS_TAC - T_digester - Q_gas, Q_ch4, Q_co2, CH4_content, P_gas - P_el, P_th</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to CSV file</p> required <code>timestamp_column</code> <code>str</code> <p>Name of timestamp column</p> <code>'timestamp'</code> <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <code>parse_dates</code> <code>bool</code> <p>Parse timestamp column</p> <code>True</code> <code>resample</code> <code>Optional[str]</code> <p>Resample frequency (e.g., \"1h\", \"1d\")</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with measurements</p> Example <p>handler = CSVHandler() data = handler.load_measurement_data( ...     \"plant_data.csv\", ...     resample=\"1h\" ... )</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def load_measurement_data(\n    self,\n    filepath: str,\n    timestamp_column: str = \"timestamp\",\n    sep: str = \",\",\n    encoding: str = \"utf-8\",\n    parse_dates: bool = True,\n    resample: Optional[str] = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Load time series measurement data from CSV.\n\n    Expected columns:\n    - timestamp (or Zeit, Zeitstempel)\n    - Q_sub_* (substrate feeds)\n    - pH, VFA, TAC, FOS_TAC\n    - T_digester\n    - Q_gas, Q_ch4, Q_co2, CH4_content, P_gas\n    - P_el, P_th\n\n    Args:\n        filepath: Path to CSV file\n        timestamp_column: Name of timestamp column\n        sep: Column separator\n        encoding: File encoding\n        parse_dates: Parse timestamp column\n        resample: Resample frequency (e.g., \"1h\", \"1d\")\n\n    Returns:\n        DataFrame with measurements\n\n    Example:\n        &gt;&gt;&gt; handler = CSVHandler()\n        &gt;&gt;&gt; data = handler.load_measurement_data(\n        ...     \"plant_data.csv\",\n        ...     resample=\"1h\"\n        ... )\n    \"\"\"\n    # Auto-detect separator\n    if sep == \"auto\":\n        sep = self._detect_separator(filepath)\n\n    # Read CSV\n    df = pd.read_csv(filepath, sep=sep, encoding=encoding)\n\n    # Map column names\n    df = self._map_column_names(df)\n\n    # Parse timestamp\n    if timestamp_column in df.columns:\n        if parse_dates:\n            df[timestamp_column] = pd.to_datetime(df[timestamp_column])\n        df = df.set_index(timestamp_column).sort_index()\n\n    # Resample if requested\n    if resample is not None:\n        df = df.resample(resample).mean()\n\n    return df\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.CSVHandler.load_multiple_substrate_samples","title":"<code>load_multiple_substrate_samples(filepath, sep=',', encoding='utf-8', date_column='sample_date', name_column='substrate_name')</code>","text":"<p>Load multiple substrate samples from CSV.</p> <p>Expected format: Each row is one sample with columns for all parameters.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to CSV file</p> required <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <code>date_column</code> <code>str</code> <p>Name of date column</p> <code>'sample_date'</code> <code>name_column</code> <code>str</code> <p>Name of substrate name column</p> <code>'substrate_name'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with substrate data</p> Example <p>handler = CSVHandler() samples = handler.load_multiple_substrate_samples( ...     \"substrate_database.csv\" ... ) print(samples.head())</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def load_multiple_substrate_samples(\n    self,\n    filepath: str,\n    sep: str = \",\",\n    encoding: str = \"utf-8\",\n    date_column: str = \"sample_date\",\n    name_column: str = \"substrate_name\",\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Load multiple substrate samples from CSV.\n\n    Expected format: Each row is one sample with columns for all parameters.\n\n    Args:\n        filepath: Path to CSV file\n        sep: Column separator\n        encoding: File encoding\n        date_column: Name of date column\n        name_column: Name of substrate name column\n\n    Returns:\n        DataFrame with substrate data\n\n    Example:\n        &gt;&gt;&gt; handler = CSVHandler()\n        &gt;&gt;&gt; samples = handler.load_multiple_substrate_samples(\n        ...     \"substrate_database.csv\"\n        ... )\n        &gt;&gt;&gt; print(samples.head())\n    \"\"\"\n    df = pd.read_csv(filepath, sep=sep, encoding=encoding)\n\n    # Map column names\n    df = self._map_column_names(df)\n\n    # Parse date column\n    if date_column in df.columns:\n        df[date_column] = pd.to_datetime(df[date_column])\n\n    return df\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.CSVHandler.load_parameter_table","title":"<code>load_parameter_table(filepath, sep=',', encoding='utf-8', index_col=None)</code>","text":"<p>Load parameter table from CSV.</p> <p>Expected format: - Rows: Parameters - Columns: Different scenarios/substrates</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to CSV file</p> required <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <code>index_col</code> <code>Optional[str]</code> <p>Column to use as index (usually parameter name)</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with parameters</p> Example <p>params = handler.load_parameter_table(\"parameters.csv\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def load_parameter_table(\n    self, filepath: str, sep: str = \",\", encoding: str = \"utf-8\", index_col: Optional[str] = None\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Load parameter table from CSV.\n\n    Expected format:\n    - Rows: Parameters\n    - Columns: Different scenarios/substrates\n\n    Args:\n        filepath: Path to CSV file\n        sep: Column separator\n        encoding: File encoding\n        index_col: Column to use as index (usually parameter name)\n\n    Returns:\n        DataFrame with parameters\n\n    Example:\n        &gt;&gt;&gt; params = handler.load_parameter_table(\"parameters.csv\")\n    \"\"\"\n    df = pd.read_csv(filepath, sep=sep, encoding=encoding, index_col=index_col)\n    return df\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.CSVHandler.load_simulation_results","title":"<code>load_simulation_results(filepath, sep=',', encoding='utf-8')</code>","text":"<p>Load simulation results from CSV.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to CSV file</p> required <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of result dicts</p> Example <p>results = handler.load_simulation_results(\"simulation.csv\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def load_simulation_results(self, filepath: str, sep: str = \",\", encoding: str = \"utf-8\") -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Load simulation results from CSV.\n\n    Args:\n        filepath: Path to CSV file\n        sep: Column separator\n        encoding: File encoding\n\n    Returns:\n        List of result dicts\n\n    Example:\n        &gt;&gt;&gt; results = handler.load_simulation_results(\"simulation.csv\")\n    \"\"\"\n    df = pd.read_csv(filepath, sep=sep, encoding=encoding)\n\n    # Convert back to results format\n    results = []\n    for _, row in df.iterrows():\n        result = {\"time\": row[\"time\"], \"components\": {}}\n\n        # Group columns by component\n        for col in df.columns:\n            if col == \"time\":\n                continue\n\n            if \"_\" in col:\n                comp_id, metric = col.split(\"_\", 1)\n                if comp_id not in result[\"components\"]:\n                    result[\"components\"][comp_id] = {}\n                result[\"components\"][comp_id][metric] = row[col]\n\n        results.append(result)\n\n    return results\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.CSVHandler.load_substrate_lab_data","title":"<code>load_substrate_lab_data(filepath, substrate_name=None, substrate_type=None, sample_date=None, sep=',', encoding='utf-8', validate=True)</code>","text":"<p>Load substrate characterization data from laboratory CSV.</p> <p>Expected columns (German or English): - Trockensubstanzgehalt (TS) [% FM] - Organische Trockensubstanz (VS) [% TS] - Fermentierbare organische Trockensubstanz (foTS) [% TS] - Rohprotein (RP) [% TS] - Rohfett (RL) [% TS] - Rohfaser (RF) [% TS] - NDF, ADF, ADL [% TS] - pH-Wert (pH) - Ammoniumstickstoff (NH4-N) [g/L or mg/L] - Alkalinit\u00e4t (TAC) [mmol/L] - Biochemisches Methanpotential (BMP) [L CH4/kg oTS] - CSB des Filtrats (COD_S) [g/L]</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to CSV file</p> required <code>substrate_name</code> <code>Optional[str]</code> <p>Substrate name (if not in file)</p> <code>None</code> <code>substrate_type</code> <code>Optional[str]</code> <p>Substrate type (maize, manure, grass, etc.)</p> <code>None</code> <code>sample_date</code> <code>Optional[Union[str, datetime]]</code> <p>Sample date (if not in file)</p> <code>None</code> <code>sep</code> <code>str</code> <p>Column separator</p> <code>','</code> <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <code>validate</code> <code>bool</code> <p>Validate data ranges</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict with substrate data</p> Example <p>handler = CSVHandler() data = handler.load_substrate_lab_data( ...     \"maize_analysis.csv\", ...     substrate_name=\"Maize silage batch 23\", ...     substrate_type=\"maize\", ...     sample_date=\"2024-01-15\" ... ) print(f\"TS: {data['TS']:.1f}% FM\")</p> Source code in <code>pyadm1ode_calibration/io/loaders/csv_handler.py</code> <pre><code>def load_substrate_lab_data(\n    self,\n    filepath: str,\n    substrate_name: Optional[str] = None,\n    substrate_type: Optional[str] = None,\n    sample_date: Optional[Union[str, datetime]] = None,\n    sep: str = \",\",\n    encoding: str = \"utf-8\",\n    validate: bool = True,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Load substrate characterization data from laboratory CSV.\n\n    Expected columns (German or English):\n    - Trockensubstanzgehalt (TS) [% FM]\n    - Organische Trockensubstanz (VS) [% TS]\n    - Fermentierbare organische Trockensubstanz (foTS) [% TS]\n    - Rohprotein (RP) [% TS]\n    - Rohfett (RL) [% TS]\n    - Rohfaser (RF) [% TS]\n    - NDF, ADF, ADL [% TS]\n    - pH-Wert (pH)\n    - Ammoniumstickstoff (NH4-N) [g/L or mg/L]\n    - Alkalinit\u00e4t (TAC) [mmol/L]\n    - Biochemisches Methanpotential (BMP) [L CH4/kg oTS]\n    - CSB des Filtrats (COD_S) [g/L]\n\n    Args:\n        filepath: Path to CSV file\n        substrate_name: Substrate name (if not in file)\n        substrate_type: Substrate type (maize, manure, grass, etc.)\n        sample_date: Sample date (if not in file)\n        sep: Column separator\n        encoding: File encoding\n        validate: Validate data ranges\n\n    Returns:\n        Dict with substrate data\n\n    Example:\n        &gt;&gt;&gt; handler = CSVHandler()\n        &gt;&gt;&gt; data = handler.load_substrate_lab_data(\n        ...     \"maize_analysis.csv\",\n        ...     substrate_name=\"Maize silage batch 23\",\n        ...     substrate_type=\"maize\",\n        ...     sample_date=\"2024-01-15\"\n        ... )\n        &gt;&gt;&gt; print(f\"TS: {data['TS']:.1f}% FM\")\n    \"\"\"\n    # Auto-detect separator if needed\n    if sep == \"auto\":\n        sep = self._detect_separator(filepath)\n\n    # Read CSV\n    df = pd.read_csv(filepath, sep=sep, encoding=encoding)\n\n    # Try to detect if file is in \"vertical\" format (parameter, value, unit)\n    if len(df.columns) &lt;= 3 and \"Parameter\" in df.columns or \"Messgr\u00f6\u00dfe\" in df.columns:\n        df = self._parse_vertical_format(df)\n\n    # Map column names\n    df = self._map_column_names(df)\n\n    # If multiple rows, take the first one (or could aggregate)\n    if len(df) &gt; 1:\n        warnings.warn(f\"CSV contains {len(df)} rows, using first row only\")\n\n    row = df.iloc[0]\n\n    # Extract data\n    result = {\n        \"substrate_name\": substrate_name or row.get(\"substrate_name\", \"Unknown\"),\n        \"substrate_type\": substrate_type or row.get(\"substrate_type\", \"unknown\"),\n        \"sample_date\": sample_date or row.get(\"sample_date\", datetime.now()),\n    }\n\n    # Add all available parameters\n    for param in [\n        \"TS\",\n        \"VS\",\n        \"oTS\",\n        \"foTS\",\n        \"RP\",\n        \"RL\",\n        \"RF\",\n        \"RA\",\n        \"NfE\",\n        \"NDF\",\n        \"ADF\",\n        \"ADL\",\n        \"pH\",\n        \"NH4_N\",\n        \"TAC\",\n        \"COD\",\n        \"COD_S\",\n        \"BMP\",\n        \"C_content\",\n        \"N_content\",\n        \"C_to_N\",\n        \"TKN\",\n    ]:\n        if param in df.columns:\n            value = row[param]\n            # Handle both scalar values and Series\n            if isinstance(value, pd.Series):\n                value = value.iloc[0] if len(value) &gt; 0 else None\n            if pd.notna(value):\n                result[param] = float(value)\n\n    # Validate if requested\n    if validate:\n        result = self._validate_substrate_data(result)\n\n    # TODO: diese Substratparameter m\u00fcssen in die substrate_....xml geschrieben werden. evtl. gibt es in einer\n    #  c# DLL auch bereits eine Methode die man aufrufen kann. glaube aber eher nicht\n\n    return result\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database","title":"<code>pyadm1ode_calibration.io.Database(connection_string=None, config=None)</code>","text":"<p>PostgreSQL database interface for PyADM1.</p> <p>Handles connection pooling, session management, and CRUD operations for all calibration-related entities.</p> <p>Parameters:</p> Name Type Description Default <code>connection_string</code> <code>Optional[str]</code> <p>Database URL.</p> <code>None</code> <code>config</code> <code>Optional[DatabaseConfig]</code> <p>Database configuration object.</p> <code>None</code> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def __init__(self, connection_string: Optional[str] = None, config: Optional[DatabaseConfig] = None):\n    self.connection_manager = ConnectionManager(connection_string, config)\n    self.engine = self.connection_manager.engine\n    self.SessionLocal = self.connection_manager.SessionLocal\n    self.connection_string = self.connection_manager.connection_string\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database-functions","title":"Functions","text":""},{"location":"api/io/#pyadm1ode_calibration.io.Database.close","title":"<code>close()</code>","text":"<p>Close the database connection and dispose of the engine.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"\n    Close the database connection and dispose of the engine.\n    \"\"\"\n    self.engine.dispose()\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.create_all_tables","title":"<code>create_all_tables()</code>","text":"<p>Create all tables defined in the ORM models.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def create_all_tables(self) -&gt; None:\n    \"\"\"\n    Create all tables defined in the ORM models.\n    \"\"\"\n    Base.metadata.create_all(bind=self.engine)\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.create_plant","title":"<code>create_plant(plant_id, name, location=None, operator=None, V_liq=None, V_gas=None, T_ad=None, P_el_nom=None, configuration=None)</code>","text":"<p>Register a new biogas plant in the database.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Unique identifier.</p> required <code>name</code> <code>str</code> <p>Human-readable name.</p> required <code>location</code> <code>Optional[str]</code> <p>Geographic location.</p> <code>None</code> <code>operator</code> <code>Optional[str]</code> <p>Entity operating the plant.</p> <code>None</code> <code>V_liq</code> <code>Optional[float]</code> <p>Liquid volume in m3.</p> <code>None</code> <code>V_gas</code> <code>Optional[float]</code> <p>Gas volume in m3.</p> <code>None</code> <code>T_ad</code> <code>Optional[float]</code> <p>Operating temperature in K.</p> <code>None</code> <code>P_el_nom</code> <code>Optional[float]</code> <p>Nominal electrical power in kW.</p> <code>None</code> <code>configuration</code> <code>Optional[Dict]</code> <p>Additional technical configuration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Plant</code> <code>Plant</code> <p>The created plant instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If plant_id already exists.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def create_plant(\n    self,\n    plant_id: str,\n    name: str,\n    location: Optional[str] = None,\n    operator: Optional[str] = None,\n    V_liq: Optional[float] = None,\n    V_gas: Optional[float] = None,\n    T_ad: Optional[float] = None,\n    P_el_nom: Optional[float] = None,\n    configuration: Optional[Dict] = None,\n) -&gt; Plant:\n    \"\"\"\n    Register a new biogas plant in the database.\n\n    Args:\n        plant_id (str): Unique identifier.\n        name (str): Human-readable name.\n        location (Optional[str]): Geographic location.\n        operator (Optional[str]): Entity operating the plant.\n        V_liq (Optional[float]): Liquid volume in m3.\n        V_gas (Optional[float]): Gas volume in m3.\n        T_ad (Optional[float]): Operating temperature in K.\n        P_el_nom (Optional[float]): Nominal electrical power in kW.\n        configuration (Optional[Dict]): Additional technical configuration.\n\n    Returns:\n        Plant: The created plant instance.\n\n    Raises:\n        ValueError: If plant_id already exists.\n    \"\"\"\n    session = self.SessionLocal()\n    try:\n        plant = Plant(\n            id=plant_id,\n            name=name,\n            location=location,\n            operator=operator,\n            V_liq=V_liq,\n            V_gas=V_gas,\n            T_ad=T_ad,\n            P_el_nom=P_el_nom,\n            configuration=configuration,\n        )\n        session.add(plant)\n        session.commit()\n        session.refresh(plant)\n        session.expunge(plant)\n        return plant\n    except IntegrityError:\n        session.rollback()\n        raise ValueError(f\"Plant with ID '{plant_id}' already exists\")\n    finally:\n        session.close()\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.drop_all_tables","title":"<code>drop_all_tables()</code>","text":"<p>Drop all tables from the database.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def drop_all_tables(self) -&gt; None:\n    \"\"\"\n    Drop all tables from the database.\n    \"\"\"\n    Base.metadata.drop_all(bind=self.engine)\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.execute_query","title":"<code>execute_query(query, params=None)</code>","text":"<p>Execute a custom read-only SQL query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>SQL query string.</p> required <code>params</code> <code>Optional[Dict[str, Any]]</code> <p>Query parameters.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Query results.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dangerous keywords are detected.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def execute_query(self, query: str, params: Optional[Dict[str, Any]] = None) -&gt; pd.DataFrame:\n    \"\"\"\n    Execute a custom read-only SQL query.\n\n    Args:\n        query (str): SQL query string.\n        params (Optional[Dict[str, Any]]): Query parameters.\n\n    Returns:\n        pd.DataFrame: Query results.\n\n    Raises:\n        ValueError: If dangerous keywords are detected.\n    \"\"\"\n    dangerous = [\"DROP\", \"DELETE\", \"TRUNCATE\", \"ALTER\"]\n    if any(kw in query.upper() for kw in dangerous):\n        raise ValueError(\"Dangerous keyword detected in query\")\n    return pd.read_sql(query, self.engine, params=params)\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.from_env","title":"<code>from_env(prefix='DB')</code>  <code>classmethod</code>","text":"<p>Create a database instance from environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix for environment variables (e.g., 'DB' -&gt; 'DB_HOST').</p> <code>'DB'</code> <p>Returns:</p> Name Type Description <code>Database</code> <code>Database</code> <p>A configured database instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required variables are missing.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>@classmethod\ndef from_env(cls, prefix: str = \"DB\") -&gt; \"Database\":\n    \"\"\"\n    Create a database instance from environment variables.\n\n    Args:\n        prefix (str): Prefix for environment variables (e.g., 'DB' -&gt; 'DB_HOST').\n\n    Returns:\n        Database: A configured database instance.\n\n    Raises:\n        ValueError: If required variables are missing.\n    \"\"\"\n    import os\n    from urllib.parse import quote_plus\n\n    host = os.getenv(f\"{prefix}_HOST\", \"localhost\")\n    port = os.getenv(f\"{prefix}_PORT\", \"5432\")\n    database = os.getenv(f\"{prefix}_NAME\")\n    username = os.getenv(f\"{prefix}_USER\")\n    password = os.getenv(f\"{prefix}_PASSWORD\")\n\n    if not all([database, username, password]):\n        raise ValueError(\"Missing required environment variables\")\n\n    conn_str = f\"postgresql://{username}:{quote_plus(password)}@{host}:{port}/{database}\"\n    return cls(connection_string=conn_str)\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.get_latest_calibration","title":"<code>get_latest_calibration(plant_id)</code>","text":"<p>Get the most recent calibration for a plant.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Plant ID.</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Optional[Dict[str, Any]]: Latest calibration record.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def get_latest_calibration(self, plant_id: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Get the most recent calibration for a plant.\n\n    Args:\n        plant_id (str): Plant ID.\n\n    Returns:\n        Optional[Dict[str, Any]]: Latest calibration record.\n    \"\"\"\n    cals = self.load_calibrations(plant_id, limit=1)\n    return cals[0] if cals else None\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.get_plant","title":"<code>get_plant(plant_id)</code>","text":"<p>Retrieve a plant by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>The plant identifier.</p> required <p>Returns:</p> Name Type Description <code>Plant</code> <code>Plant</code> <p>The plant instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If plant is not found.</p> <code>DatabaseError</code> <p>On SQL failure.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def get_plant(self, plant_id: str) -&gt; Plant:\n    \"\"\"\n    Retrieve a plant by its ID.\n\n    Args:\n        plant_id (str): The plant identifier.\n\n    Returns:\n        Plant: The plant instance.\n\n    Raises:\n        ValueError: If plant is not found.\n        DatabaseError: On SQL failure.\n    \"\"\"\n    session = self.SessionLocal()\n    try:\n        plant = session.query(Plant).filter(Plant.id == plant_id).first()\n        if plant is None:\n            raise ValueError(f\"Plant '{plant_id}' not found\")\n        session.expunge(plant)\n        return plant\n    except SQLAlchemyError as e:\n        raise DatabaseError(f\"Failed to retrieve plant '{plant_id}': {e}\")\n    finally:\n        session.close()\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.get_session","title":"<code>get_session()</code>","text":"<p>Context manager for SQLAlchemy database sessions.</p> <p>Yields:</p> Name Type Description <code>Session</code> <code>Session</code> <p>An active database session.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>@contextmanager\ndef get_session(self) -&gt; Session:\n    \"\"\"\n    Context manager for SQLAlchemy database sessions.\n\n    Yields:\n        Session: An active database session.\n    \"\"\"\n    session = self.SessionLocal()\n    try:\n        yield session\n        session.commit()\n    except Exception:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.get_statistics","title":"<code>get_statistics(plant_id)</code>","text":"<p>Get database usage statistics for a specific plant.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Plant ID.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Counts and time ranges of stored data.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def get_statistics(self, plant_id: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get database usage statistics for a specific plant.\n\n    Args:\n        plant_id (str): Plant ID.\n\n    Returns:\n        Dict[str, Any]: Counts and time ranges of stored data.\n    \"\"\"\n    with self.get_session() as session:\n        return {\n            \"plant_id\": plant_id,\n            \"n_measurements\": session.query(Measurement).filter(Measurement.plant_id == plant_id).count(),\n            \"n_simulations\": session.query(Simulation).filter(Simulation.plant_id == plant_id).count(),\n            \"n_calibrations\": session.query(Calibration).filter(Calibration.plant_id == plant_id).count(),\n            \"n_substrates\": session.query(Substrate).filter(Substrate.plant_id == plant_id).count(),\n            \"first_measurement\": (\n                session.query(Measurement.timestamp)\n                .filter(Measurement.plant_id == plant_id)\n                .order_by(Measurement.timestamp)\n                .first()[0]\n                if session.query(Measurement.timestamp).filter(Measurement.plant_id == plant_id).count() &gt; 0\n                else None\n            ),\n            \"last_measurement\": (\n                session.query(Measurement.timestamp)\n                .filter(Measurement.plant_id == plant_id)\n                .order_by(Measurement.timestamp.desc())\n                .first()[0]\n                if session.query(Measurement.timestamp).filter(Measurement.plant_id == plant_id).count() &gt; 0\n                else None\n            ),\n        }\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.list_plants","title":"<code>list_plants()</code>","text":"<p>List all registered plants.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: List of plant summary dictionaries.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def list_plants(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    List all registered plants.\n\n    Returns:\n        List[Dict[str, Any]]: List of plant summary dictionaries.\n    \"\"\"\n    with self.get_session() as session:\n        plants = session.query(Plant).all()\n        return [\n            {\n                \"id\": p.id,\n                \"name\": p.name,\n                \"location\": p.location,\n                \"V_liq\": p.V_liq,\n                \"V_gas\": p.V_gas,\n                \"T_ad\": p.T_ad,\n                \"created_at\": p.created_at,\n            }\n            for p in plants\n        ]\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.list_simulations","title":"<code>list_simulations(plant_id=None, scenario=None)</code>","text":"<p>List simulations matching specific criteria.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>Optional[str]</code> <p>Filter by plant.</p> <code>None</code> <code>scenario</code> <code>Optional[str]</code> <p>Filter by scenario.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: List of simulation summaries.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def list_simulations(self, plant_id: Optional[str] = None, scenario: Optional[str] = None) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    List simulations matching specific criteria.\n\n    Args:\n        plant_id (Optional[str]): Filter by plant.\n        scenario (Optional[str]): Filter by scenario.\n\n    Returns:\n        List[Dict[str, Any]]: List of simulation summaries.\n    \"\"\"\n    with self.get_session() as session:\n        query = session.query(Simulation)\n        if plant_id:\n            query = query.filter(Simulation.plant_id == plant_id)\n        if scenario:\n            query = query.filter(Simulation.scenario == scenario)\n        simulations = query.order_by(Simulation.created_at.desc()).all()\n        return [\n            {\n                \"id\": s.id,\n                \"plant_id\": s.plant_id,\n                \"name\": s.name,\n                \"scenario\": s.scenario,\n                \"duration\": s.duration,\n                \"avg_Q_ch4\": s.avg_Q_ch4,\n                \"status\": s.status,\n                \"created_at\": s.created_at,\n            }\n            for s in simulations\n        ]\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.load_calibrations","title":"<code>load_calibrations(plant_id, calibration_type=None, limit=10)</code>","text":"<p>Load past calibrations for a plant.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Plant ID.</p> required <code>calibration_type</code> <code>Optional[str]</code> <p>Filter by type.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Max records to return.</p> <code>10</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: List of calibration records.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def load_calibrations(\n    self, plant_id: str, calibration_type: Optional[str] = None, limit: int = 10\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Load past calibrations for a plant.\n\n    Args:\n        plant_id (str): Plant ID.\n        calibration_type (Optional[str]): Filter by type.\n        limit (int): Max records to return.\n\n    Returns:\n        List[Dict[str, Any]]: List of calibration records.\n    \"\"\"\n    with self.get_session() as session:\n        query = session.query(Calibration).filter(Calibration.plant_id == plant_id)\n        if calibration_type:\n            query = query.filter(Calibration.calibration_type == calibration_type)\n        cals = query.order_by(Calibration.created_at.desc()).limit(limit).all()\n        return [{c.name: getattr(cal, c.name) for c in Calibration.__table__.columns} for cal in cals]\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.load_measurements","title":"<code>load_measurements(plant_id, start_time=None, end_time=None, columns=None, source=None)</code>","text":"<p>Load measurements as a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Plant ID.</p> required <code>start_time</code> <code>Optional[datetime]</code> <p>Start of window.</p> <code>None</code> <code>end_time</code> <code>Optional[datetime]</code> <p>End of window.</p> <code>None</code> <code>columns</code> <code>Optional[List[str]]</code> <p>Specific columns to load.</p> <code>None</code> <code>source</code> <code>Optional[str]</code> <p>Filter by data source.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Measurements indexed by timestamp.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def load_measurements(self, plant_id: str, start_time=None, end_time=None, columns=None, source=None) -&gt; pd.DataFrame:\n    \"\"\"\n    Load measurements as a pandas DataFrame.\n\n    Args:\n        plant_id (str): Plant ID.\n        start_time (Optional[datetime]): Start of window.\n        end_time (Optional[datetime]): End of window.\n        columns (Optional[List[str]]): Specific columns to load.\n        source (Optional[str]): Filter by data source.\n\n    Returns:\n        pd.DataFrame: Measurements indexed by timestamp.\n    \"\"\"\n    if isinstance(start_time, str):\n        start_time = pd.to_datetime(start_time)\n    if isinstance(end_time, str):\n        end_time = pd.to_datetime(end_time)\n    with self.get_session() as session:\n        query = session.query(Measurement).filter(Measurement.plant_id == plant_id)\n        if start_time:\n            query = query.filter(Measurement.timestamp &gt;= start_time)\n        if end_time:\n            query = query.filter(Measurement.timestamp &lt;= end_time)\n        if source:\n            query = query.filter(Measurement.source == source)\n        results = query.order_by(Measurement.timestamp).all()\n        if not results:\n            return pd.DataFrame()\n        data_dict = {\"timestamp\": [r.timestamp for r in results]}\n        if columns is None:\n            columns = [\n                c.name\n                for c in Measurement.__table__.columns\n                if c.name not in [\"id\", \"plant_id\", \"timestamp\", \"source\", \"created_at\"]\n            ]\n        for col in columns:\n            data_dict[col] = [getattr(r, col) for r in results]\n        return pd.DataFrame(data_dict).set_index(\"timestamp\")\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.load_simulation","title":"<code>load_simulation(simulation_id)</code>","text":"<p>Load simulation metadata and its full time series.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_id</code> <code>str</code> <p>ID of the simulation.</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Optional[Dict[str, Any]]: Dictionary containing metadata and 'time_series' DataFrame.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def load_simulation(self, simulation_id: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Load simulation metadata and its full time series.\n\n    Args:\n        simulation_id (str): ID of the simulation.\n\n    Returns:\n        Optional[Dict[str, Any]]: Dictionary containing metadata and 'time_series' DataFrame.\n    \"\"\"\n    with self.get_session() as session:\n        sim = session.query(Simulation).filter(Simulation.id == simulation_id).first()\n        if not sim:\n            return None\n        ts = (\n            session.query(SimulationTimeSeries)\n            .filter(SimulationTimeSeries.simulation_id == simulation_id)\n            .order_by(SimulationTimeSeries.time)\n            .all()\n        )\n        df = (\n            pd.DataFrame(\n                {\n                    c.name: [getattr(t, c.name) for t in ts]\n                    for c in SimulationTimeSeries.__table__.columns\n                    if c.name not in [\"id\", \"simulation_id\"]\n                }\n            )\n            if ts\n            else pd.DataFrame()\n        )\n        return {**{c.name: getattr(sim, c.name) for c in Simulation.__table__.columns}, \"time_series\": df}\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.load_substrates","title":"<code>load_substrates(plant_id, substrate_type=None, start_date=None, end_date=None)</code>","text":"<p>Load substrate data as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Plant ID.</p> required <code>substrate_type</code> <code>Optional[str]</code> <p>Filter by type.</p> <code>None</code> <code>start_date</code> <code>Optional[datetime]</code> <p>Start date.</p> <code>None</code> <code>end_date</code> <code>Optional[datetime]</code> <p>End date.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Table of substrate analyses.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def load_substrates(\n    self,\n    plant_id: str,\n    substrate_type: Optional[str] = None,\n    start_date: Optional[Union[str, datetime]] = None,\n    end_date: Optional[Union[str, datetime]] = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Load substrate data as a DataFrame.\n\n    Args:\n        plant_id (str): Plant ID.\n        substrate_type (Optional[str]): Filter by type.\n        start_date (Optional[datetime]): Start date.\n        end_date (Optional[datetime]): End date.\n\n    Returns:\n        pd.DataFrame: Table of substrate analyses.\n    \"\"\"\n    if isinstance(start_date, str):\n        start_date = pd.to_datetime(start_date)\n    if isinstance(end_date, str):\n        end_date = pd.to_datetime(end_date)\n    with self.get_session() as session:\n        query = session.query(Substrate).filter(Substrate.plant_id == plant_id)\n        if substrate_type:\n            query = query.filter(Substrate.substrate_type == substrate_type)\n        if start_date:\n            query = query.filter(Substrate.sample_date &gt;= start_date)\n        if end_date:\n            query = query.filter(Substrate.sample_date &lt;= end_date)\n        substrates = query.order_by(Substrate.sample_date).all()\n        if not substrates:\n            return pd.DataFrame()\n        cols = [\n            \"sample_date\",\n            \"substrate_name\",\n            \"substrate_type\",\n            \"sample_id\",\n            \"TS\",\n            \"VS\",\n            \"oTS\",\n            \"foTS\",\n            \"RP\",\n            \"RL\",\n            \"RF\",\n            \"NDF\",\n            \"ADF\",\n            \"ADL\",\n            \"pH\",\n            \"NH4_N\",\n            \"TAC\",\n            \"COD_S\",\n            \"BMP\",\n            \"C_to_N\",\n            \"lab_name\",\n        ]\n        return pd.DataFrame([{c: getattr(s, c) for c in cols} for s in substrates])\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.store_calibration","title":"<code>store_calibration(plant_id, calibration_type, method, parameters, objective_value, objectives, validation_metrics=None, data_start=None, data_end=None, success=True, message=None)</code>","text":"<p>Store a calibration result.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Plant ID.</p> required <code>calibration_type</code> <code>str</code> <p>'initial' or 'online'.</p> required <code>method</code> <code>str</code> <p>Optimization method.</p> required <code>parameters</code> <code>Dict[str, float]</code> <p>Calibrated values.</p> required <code>objective_value</code> <code>float</code> <p>Final cost value.</p> required <code>objectives</code> <code>List[str]</code> <p>Variables used in objective.</p> required <code>validation_metrics</code> <code>Optional[Dict[str, float]]</code> <p>RMSE, R2 etc.</p> <code>None</code> <code>data_start</code> <code>Optional[datetime]</code> <p>Start of data window.</p> <code>None</code> <code>data_end</code> <code>Optional[datetime]</code> <p>End of data window.</p> <code>None</code> <code>success</code> <code>bool</code> <p>Whether calibration converged.</p> <code>True</code> <code>message</code> <code>Optional[str]</code> <p>Status message.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Calibration</code> <code>Calibration</code> <p>Stored record.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def store_calibration(\n    self,\n    plant_id: str,\n    calibration_type: str,\n    method: str,\n    parameters: Dict[str, float],\n    objective_value: float,\n    objectives: List[str],\n    validation_metrics: Optional[Dict[str, float]] = None,\n    data_start: Optional[datetime] = None,\n    data_end: Optional[datetime] = None,\n    success: bool = True,\n    message: Optional[str] = None,\n) -&gt; Calibration:\n    \"\"\"\n    Store a calibration result.\n\n    Args:\n        plant_id (str): Plant ID.\n        calibration_type (str): 'initial' or 'online'.\n        method (str): Optimization method.\n        parameters (Dict[str, float]): Calibrated values.\n        objective_value (float): Final cost value.\n        objectives (List[str]): Variables used in objective.\n        validation_metrics (Optional[Dict[str, float]]): RMSE, R2 etc.\n        data_start (Optional[datetime]): Start of data window.\n        data_end (Optional[datetime]): End of data window.\n        success (bool): Whether calibration converged.\n        message (Optional[str]): Status message.\n\n    Returns:\n        Calibration: Stored record.\n    \"\"\"\n    with self.get_session() as session:\n        cal = Calibration(\n            plant_id=plant_id,\n            calibration_type=calibration_type,\n            method=method,\n            parameters=parameters,\n            objective_value=objective_value,\n            objectives=objectives,\n            validation_metrics=validation_metrics,\n            data_start=data_start,\n            data_end=data_end,\n            success=success,\n            message=message,\n        )\n        session.add(cal)\n        return cal\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.store_measurements","title":"<code>store_measurements(plant_id, data, source='SCADA', validate=True)</code>","text":"<p>Bulk store measurement data for a plant.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>ID of the plant.</p> required <code>data</code> <code>DataFrame</code> <p>Measurements with 'timestamp' column.</p> required <code>source</code> <code>str</code> <p>Data source name. Defaults to 'SCADA'.</p> <code>'SCADA'</code> <code>validate</code> <code>bool</code> <p>Whether to run quality checks before storing.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of records stored.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def store_measurements(self, plant_id: str, data: pd.DataFrame, source: str = \"SCADA\", validate: bool = True) -&gt; int:\n    \"\"\"\n    Bulk store measurement data for a plant.\n\n    Args:\n        plant_id (str): ID of the plant.\n        data (pd.DataFrame): Measurements with 'timestamp' column.\n        source (str): Data source name. Defaults to 'SCADA'.\n        validate (bool): Whether to run quality checks before storing.\n\n    Returns:\n        int: Number of records stored.\n    \"\"\"\n    self.get_plant(plant_id)\n    if \"timestamp\" not in data.columns:\n        raise ValueError(\"DataFrame must have 'timestamp' column\")\n    if not pd.api.types.is_datetime64_any_dtype(data[\"timestamp\"]):\n        data[\"timestamp\"] = pd.to_datetime(data[\"timestamp\"])\n    if validate:\n        from ..validation.validators import DataValidator\n\n        DataValidator.validate(data)\n\n    records = []\n    for _, row in data.iterrows():\n        record = {\"plant_id\": plant_id, \"timestamp\": row[\"timestamp\"], \"source\": source}\n        for col in data.columns:\n            if col != \"timestamp\" and col in Measurement.__table__.columns:\n                val = row[col]\n                if pd.notna(val):\n                    record[col] = float(val) if isinstance(val, (int, float, np.number)) else val\n        records.append(record)\n    with self.get_session() as session:\n        try:\n            session.bulk_insert_mappings(Measurement, records)\n            return len(records)\n        except SQLAlchemyError as e:\n            raise DatabaseError(f\"Failed to store measurements: {e}\")\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.store_simulation","title":"<code>store_simulation(simulation_id, plant_id, results, name=None, description=None, duration=None, parameters=None, scenario='baseline')</code>","text":"<p>Store simulation metadata and time series.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_id</code> <code>str</code> <p>Unique ID for the simulation.</p> required <code>plant_id</code> <code>str</code> <p>Associated plant ID.</p> required <code>results</code> <code>List[Dict[str, Any]]</code> <p>Time-series results from simulation.</p> required <code>name</code> <code>Optional[str]</code> <p>Simulation name.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional description.</p> <code>None</code> <code>duration</code> <code>Optional[float]</code> <p>Duration in days.</p> <code>None</code> <code>parameters</code> <code>Optional[Dict]</code> <p>Parameters used in this run.</p> <code>None</code> <code>scenario</code> <code>str</code> <p>Scenario label. Defaults to 'baseline'.</p> <code>'baseline'</code> <p>Returns:</p> Name Type Description <code>Simulation</code> <code>Simulation</code> <p>Stored simulation record.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def store_simulation(\n    self,\n    simulation_id: str,\n    plant_id: str,\n    results: List[Dict[str, Any]],\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    duration: Optional[float] = None,\n    parameters: Optional[Dict] = None,\n    scenario: str = \"baseline\",\n) -&gt; Simulation:\n    \"\"\"\n    Store simulation metadata and time series.\n\n    Args:\n        simulation_id (str): Unique ID for the simulation.\n        plant_id (str): Associated plant ID.\n        results (List[Dict[str, Any]]): Time-series results from simulation.\n        name (Optional[str]): Simulation name.\n        description (Optional[str]): Optional description.\n        duration (Optional[float]): Duration in days.\n        parameters (Optional[Dict]): Parameters used in this run.\n        scenario (str): Scenario label. Defaults to 'baseline'.\n\n    Returns:\n        Simulation: Stored simulation record.\n    \"\"\"\n    self.get_plant(plant_id)\n    metrics = self._calculate_simulation_metrics(results)\n    with self.get_session() as session:\n        sim = Simulation(\n            id=simulation_id,\n            plant_id=plant_id,\n            name=name,\n            description=description,\n            duration=duration or (results[-1][\"time\"] if results else 0),\n            scenario=scenario,\n            parameters=parameters,\n            avg_Q_gas=metrics.get(\"avg_Q_gas\"),\n            avg_Q_ch4=metrics.get(\"avg_Q_ch4\"),\n            avg_CH4_content=metrics.get(\"avg_CH4_content\"),\n            avg_pH=metrics.get(\"avg_pH\"),\n            avg_VFA=metrics.get(\"avg_VFA\"),\n            total_energy=metrics.get(\"total_energy\"),\n            status=\"completed\",\n            started_at=datetime.utcnow(),\n            completed_at=datetime.utcnow(),\n        )\n        try:\n            session.add(sim)\n            session.flush()\n            ts_records = []\n            for res in results:\n                comp_data = next(iter(res[\"components\"].values()))\n                record = {\n                    \"simulation_id\": simulation_id,\n                    \"time\": res[\"time\"],\n                    \"Q_gas\": comp_data.get(\"Q_gas\"),\n                    \"Q_ch4\": comp_data.get(\"Q_ch4\"),\n                    \"Q_co2\": comp_data.get(\"Q_co2\"),\n                    \"pH\": comp_data.get(\"pH\"),\n                    \"VFA\": comp_data.get(\"VFA\"),\n                    \"TAC\": comp_data.get(\"TAC\"),\n                }\n                if record[\"Q_gas\"] and record[\"Q_ch4\"] and record[\"Q_gas\"] &gt; 0:\n                    record[\"CH4_content\"] = (record[\"Q_ch4\"] / record[\"Q_gas\"]) * 100\n                ts_records.append(record)\n            session.bulk_insert_mappings(SimulationTimeSeries, ts_records)\n            return sim\n        except IntegrityError:\n            raise ValueError(f\"Simulation with ID '{simulation_id}' already exists\")\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.Database.store_substrate","title":"<code>store_substrate(plant_id, substrate_name, substrate_type, sample_date, lab_data, sample_id=None, lab_name=None, notes=None)</code>","text":"<p>Store substrate laboratory analysis data.</p> <p>Parameters:</p> Name Type Description Default <code>plant_id</code> <code>str</code> <p>Associated plant ID.</p> required <code>substrate_name</code> <code>str</code> <p>Name (e.g., 'Maize Silage').</p> required <code>substrate_type</code> <code>str</code> <p>Category.</p> required <code>sample_date</code> <code>datetime</code> <p>Date of sampling.</p> required <code>lab_data</code> <code>Dict[str, float]</code> <p>Chemical properties (TS, VS, oTS, etc.).</p> required <code>sample_id</code> <code>Optional[str]</code> <p>Lab internal ID.</p> <code>None</code> <code>lab_name</code> <code>Optional[str]</code> <p>Lab name.</p> <code>None</code> <code>notes</code> <code>Optional[str]</code> <p>Additional comments.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Substrate</code> <code>Substrate</code> <p>Stored record.</p> Source code in <code>pyadm1ode_calibration/io/persistence/database.py</code> <pre><code>def store_substrate(\n    self,\n    plant_id: str,\n    substrate_name: str,\n    substrate_type: str,\n    sample_date: Union[str, datetime],\n    lab_data: Dict[str, float],\n    sample_id: Optional[str] = None,\n    lab_name: Optional[str] = None,\n    notes: Optional[str] = None,\n) -&gt; Substrate:\n    \"\"\"\n    Store substrate laboratory analysis data.\n\n    Args:\n        plant_id (str): Associated plant ID.\n        substrate_name (str): Name (e.g., 'Maize Silage').\n        substrate_type (str): Category.\n        sample_date (datetime): Date of sampling.\n        lab_data (Dict[str, float]): Chemical properties (TS, VS, oTS, etc.).\n        sample_id (Optional[str]): Lab internal ID.\n        lab_name (Optional[str]): Lab name.\n        notes (Optional[str]): Additional comments.\n\n    Returns:\n        Substrate: Stored record.\n    \"\"\"\n    if isinstance(sample_date, str):\n        sample_date = pd.to_datetime(sample_date)\n    session = self.SessionLocal()\n    try:\n        substrate = Substrate(\n            plant_id=plant_id,\n            substrate_name=substrate_name,\n            substrate_type=substrate_type,\n            sample_date=sample_date,\n            sample_id=sample_id,\n            lab_name=lab_name,\n            notes=notes,\n        )\n        for key, value in lab_data.items():\n            if hasattr(substrate, key):\n                setattr(substrate, key, value)\n        session.add(substrate)\n        session.commit()\n        session.refresh(substrate)\n        session.expunge(substrate)\n        return substrate\n    except Exception:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n</code></pre>"},{"location":"api/io/#pyadm1ode_calibration.io.DataValidator","title":"<code>pyadm1ode_calibration.io.DataValidator</code>","text":"<p>Validates measurement data quality and consistency.</p>"},{"location":"api/io/#pyadm1ode_calibration.io.DataValidator-functions","title":"Functions","text":""},{"location":"api/io/#pyadm1ode_calibration.io.DataValidator.validate","title":"<code>validate(data, required_columns=None, expected_ranges=None)</code>  <code>staticmethod</code>","text":"<p>Perform comprehensive data validation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame to validate</p> required <code>required_columns</code> <code>Optional[List[str]]</code> <p>Columns that must be present</p> <code>None</code> <code>expected_ranges</code> <code>Optional[Dict[str, Tuple[float, float]]]</code> <p>Mapping of column names to (min, max)</p> <code>None</code> <p>Returns:</p> Type Description <code>ValidationResult</code> <p>ValidationResult object</p> Source code in <code>pyadm1ode_calibration/io/validation/validators.py</code> <pre><code>@staticmethod\ndef validate(\n    data: pd.DataFrame,\n    required_columns: Optional[List[str]] = None,\n    expected_ranges: Optional[Dict[str, Tuple[float, float]]] = None,\n) -&gt; ValidationResult:\n    \"\"\"\n    Perform comprehensive data validation.\n\n    Args:\n        data: DataFrame to validate\n        required_columns: Columns that must be present\n        expected_ranges: Mapping of column names to (min, max)\n\n    Returns:\n        ValidationResult object\n    \"\"\"\n    issues = []\n    warnings = []\n    missing_counts = data.isnull().sum().to_dict()\n    missing_pct = data.isnull().mean()\n\n    # 1. Check required columns\n    if required_columns:\n        for col in required_columns:\n            if col not in data.columns:\n                issues.append(f\"Required column '{col}' is missing\")\n\n    # 2. Check for empty data\n    if data.empty:\n        issues.append(\"Dataset is empty\")\n        return ValidationResult(is_valid=False, quality_score=0.0, issues=issues, missing_data=missing_counts)\n\n    # 3. Check for missing values (NaN)\n    for col, pct in missing_pct.items():\n        if pct &gt; 0.3:\n            issues.append(f\"Column '{col}' has {pct*100:.1f}% missing values\")\n        elif pct &gt; 0:\n            warnings.append(f\"Column '{col}' has {pct*100:.1f}% missing values\")\n\n    # 4. Check expected ranges\n    if expected_ranges:\n        for col, (vmin, vmax) in expected_ranges.items():\n            if col in data.columns:\n                out_of_range = (data[col] &lt; vmin) | (data[col] &gt; vmax)\n                n_out = out_of_range.sum()\n                if n_out &gt; 0:\n                    pct = n_out / len(data)\n                    if pct &gt; 0.2:\n                        issues.append(f\"Column '{col}' has {n_out} values outside range [{vmin}, {vmax}]\")\n                    else:\n                        warnings.append(f\"Column '{col}' has {n_out} values outside range [{vmin}, {vmax}]\")\n\n    # 5. Check for duplicates in index (timestamps)\n    if data.index.duplicated().any():\n        issues.append(\"Dataset has duplicate timestamps\")\n\n    # Calculate quality score\n    quality_score = DataValidator._calculate_quality_score(len(issues), len(warnings), missing_pct.mean())\n\n    return ValidationResult(\n        is_valid=len(issues) == 0,\n        quality_score=quality_score,\n        issues=issues,\n        warnings=warnings,\n        missing_data=missing_counts,\n        statistics={\"missing_pct_avg\": float(missing_pct.mean())},\n    )\n</code></pre>"},{"location":"api/optimization/","title":"Optimization API","text":""},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.optimizer.Optimizer","title":"<code>pyadm1ode_calibration.calibration.optimization.optimizer.Optimizer(bounds, max_iterations=100, tolerance=1e-06, verbose=True)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for optimization algorithms.</p> <p>All optimizers must implement the optimize() method and provide a consistent interface for parameter calibration.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Dict[str, Tuple[float, float]]</code> <p>Parameter bounds as {name: (min, max)}.</p> required <code>max_iterations</code> <code>int</code> <p>Maximum number of iterations. Defaults to 100.</p> <code>100</code> <code>tolerance</code> <code>float</code> <p>Convergence tolerance. Defaults to 1e-6.</p> <code>1e-06</code> <code>verbose</code> <code>bool</code> <p>Whether to enable progress output. Defaults to True.</p> <code>True</code> Source code in <code>pyadm1ode_calibration/calibration/optimization/optimizer.py</code> <pre><code>def __init__(\n    self,\n    bounds: Dict[str, Tuple[float, float]],\n    max_iterations: int = 100,\n    tolerance: float = 1e-6,\n    verbose: bool = True,\n):\n    self.bounds = bounds\n    self.max_iterations = max_iterations\n    self.tolerance = tolerance\n    self.verbose = verbose\n\n    self.parameter_names = list(bounds.keys())\n    self.bounds_array = np.array([bounds[name] for name in self.parameter_names])\n\n    # History tracking\n    self.history: List[Dict[str, Any]] = []\n    self._best_value = float(\"inf\")\n    self._n_evaluations = 0\n</code></pre>"},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.optimizer.Optimizer-functions","title":"Functions","text":""},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.optimizer.Optimizer.optimize","title":"<code>optimize(objective_func, initial_guess=None)</code>  <code>abstractmethod</code>","text":"<p>Run the optimization process.</p> <p>Parameters:</p> Name Type Description Default <code>objective_func</code> <code>Callable</code> <p>Function to minimize f(x) -&gt; float.</p> required <code>initial_guess</code> <code>Optional[ndarray]</code> <p>Optional starting point for the optimizer.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OptimizationResult</code> <code>OptimizationResult</code> <p>The result of the optimization.</p> Source code in <code>pyadm1ode_calibration/calibration/optimization/optimizer.py</code> <pre><code>@abstractmethod\ndef optimize(\n    self, objective_func: Callable[[np.ndarray], float], initial_guess: Optional[np.ndarray] = None\n) -&gt; OptimizationResult:\n    \"\"\"\n    Run the optimization process.\n\n    Args:\n        objective_func (Callable): Function to minimize f(x) -&gt; float.\n        initial_guess (Optional[np.ndarray]): Optional starting point for the optimizer.\n\n    Returns:\n        OptimizationResult: The result of the optimization.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.objective.MultiObjectiveFunction","title":"<code>pyadm1ode_calibration.calibration.optimization.objective.MultiObjectiveFunction(simulator, measurements_dict, objectives, weights, parameter_names, error_metric='rmse', normalize=True)</code>","text":"<p>               Bases: <code>ObjectiveFunction</code></p> <p>Multi-objective function with weighted combination.</p> <p>Combines errors from multiple plant outputs into a single scalar value.</p> <p>Parameters:</p> Name Type Description Default <code>simulator</code> <code>Callable</code> <p>Function that takes parameters and returns outputs.</p> required <code>measurements_dict</code> <code>Dict[str, ndarray]</code> <p>Measured values for each objective.</p> required <code>objectives</code> <code>List[str]</code> <p>Names of variables to include in the objective.</p> required <code>weights</code> <code>Dict[str, float]</code> <p>Relative weights for each objective.</p> required <code>parameter_names</code> <code>List[str]</code> <p>Names of optimized parameters.</p> required <code>error_metric</code> <code>str</code> <p>Metric to minimize (e.g., 'rmse', 'mae'). Defaults to 'rmse'.</p> <code>'rmse'</code> <code>normalize</code> <code>bool</code> <p>Whether to normalize errors by measurement mean. Defaults to True.</p> <code>True</code> Source code in <code>pyadm1ode_calibration/calibration/optimization/objective.py</code> <pre><code>def __init__(\n    self,\n    simulator: Callable[[Dict[str, float]], Dict[str, np.ndarray]],\n    measurements_dict: Dict[str, np.ndarray],\n    objectives: List[str],\n    weights: Dict[str, float],\n    parameter_names: List[str],\n    error_metric: str = \"rmse\",\n    normalize: bool = True,\n):\n    super().__init__(parameter_names)\n    self.simulator = simulator\n    self.measurements_dict = measurements_dict\n    self.objectives = objectives\n    self.weights = weights\n    self.error_metric = error_metric.lower()\n    self.normalize = normalize\n\n    total_weight = sum(weights.values())\n    if total_weight &gt; 0:\n        self.weights = {k: v / total_weight for k, v in weights.items()}\n</code></pre>"},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.objective.MultiObjectiveFunction-functions","title":"Functions","text":""},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.objective.MultiObjectiveFunction.__call__","title":"<code>__call__(x)</code>","text":"<p>Evaluate the multi-objective weighted sum.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Parameter array.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Total weighted error.</p> Source code in <code>pyadm1ode_calibration/calibration/optimization/objective.py</code> <pre><code>def __call__(self, x: np.ndarray) -&gt; float:\n    \"\"\"\n    Evaluate the multi-objective weighted sum.\n\n    Args:\n        x (np.ndarray): Parameter array.\n\n    Returns:\n        float: Total weighted error.\n    \"\"\"\n    params = self._params_to_dict(x)\n    try:\n        outputs = self.simulator(params)\n        total_error = 0.0\n        n_valid = 0\n\n        for obj_name in self.objectives:\n            if obj_name not in outputs or obj_name not in self.measurements_dict:\n                continue\n\n            simulated = outputs[obj_name]\n            measured = self.measurements_dict[obj_name]\n            metrics = ErrorMetrics.compute(measured, simulated)\n\n            error_map = {\n                \"mse\": metrics.mse,\n                \"rmse\": metrics.rmse,\n                \"mae\": metrics.mae,\n                \"mape\": metrics.mape,\n                \"nse\": -metrics.nse,\n                \"r2\": -metrics.r2,\n            }\n            error = error_map.get(self.error_metric, metrics.rmse)\n\n            if self.normalize:\n                mean_measured = np.mean(np.abs(measured))\n                if mean_measured &gt; 1e-10:\n                    error /= mean_measured\n\n            total_error += self.weights.get(obj_name, 0.0) * error\n            n_valid += 1\n\n        return total_error if n_valid &gt; 0 else 1e10\n    except Exception:\n        return 1e10\n</code></pre>"},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.constraints.ParameterConstraints","title":"<code>pyadm1ode_calibration.calibration.optimization.constraints.ParameterConstraints(penalty_function=None)</code>","text":"<p>Manager for parameter constraints.</p> Source code in <code>pyadm1ode_calibration/calibration/optimization/constraints.py</code> <pre><code>def __init__(self, penalty_function: Optional[PenaltyFunction] = None):\n    self.box_constraints: Dict[str, BoxConstraint] = {}\n    self.linear_constraints: List[LinearConstraint] = []\n    self.nonlinear_constraints: List[NonlinearConstraint] = []\n    self.penalty_function = penalty_function or QuadraticPenalty()\n    self.penalty_weights: Dict[str, float] = {}\n</code></pre>"},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.constraints.ParameterConstraints-functions","title":"Functions","text":""},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.constraints.ParameterConstraints.add_box_constraint","title":"<code>add_box_constraint(parameter_name, lower, upper, hard=True, weight=1.0)</code>","text":"<p>Add box constraint.</p> Source code in <code>pyadm1ode_calibration/calibration/optimization/constraints.py</code> <pre><code>def add_box_constraint(self, parameter_name: str, lower: float, upper: float, hard: bool = True, weight: float = 1.0):\n    \"\"\"Add box constraint.\"\"\"\n    self.box_constraints[parameter_name] = BoxConstraint(parameter_name, lower, upper, hard)\n    if not hard:\n        self.penalty_weights[f\"box_{parameter_name}\"] = weight\n</code></pre>"},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.constraints.ParameterConstraints.add_linear_equality","title":"<code>add_linear_equality(coefficients, target, weight=1.0)</code>","text":"<p>Add linear equality.</p> Source code in <code>pyadm1ode_calibration/calibration/optimization/constraints.py</code> <pre><code>def add_linear_equality(self, coefficients, target, weight=1.0):\n    \"\"\"Add linear equality.\"\"\"\n    c = LinearConstraint(coefficients, None, target, \"equality\")\n    self.linear_constraints.append(c)\n    self.penalty_weights[f\"linear_eq_{len(self.linear_constraints)}\"] = weight\n</code></pre>"},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.constraints.ParameterConstraints.add_linear_inequality","title":"<code>add_linear_inequality(coefficients, lower_bound=None, upper_bound=None, weight=1.0)</code>","text":"<p>Add linear inequality.</p> Source code in <code>pyadm1ode_calibration/calibration/optimization/constraints.py</code> <pre><code>def add_linear_inequality(self, coefficients, lower_bound=None, upper_bound=None, weight=1.0):\n    \"\"\"Add linear inequality.\"\"\"\n    c = LinearConstraint(coefficients, lower_bound, upper_bound, \"inequality\")\n    self.linear_constraints.append(c)\n    self.penalty_weights[f\"linear_{len(self.linear_constraints)}\"] = weight\n</code></pre>"},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.constraints.ParameterConstraints.add_nonlinear_constraint","title":"<code>add_nonlinear_constraint(name, function, constraint_type='inequality', weight=1.0)</code>","text":"<p>Add nonlinear constraint.</p> Source code in <code>pyadm1ode_calibration/calibration/optimization/constraints.py</code> <pre><code>def add_nonlinear_constraint(self, name, function, constraint_type=\"inequality\", weight=1.0):\n    \"\"\"Add nonlinear constraint.\"\"\"\n    c = NonlinearConstraint(name, function, constraint_type)\n    self.nonlinear_constraints.append(c)\n    self.penalty_weights[f\"nonlinear_{name}\"] = weight\n</code></pre>"},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.constraints.ParameterConstraints.calculate_penalty","title":"<code>calculate_penalty(parameters)</code>","text":"<p>Calculate total penalty for all violated constraints.</p> Source code in <code>pyadm1ode_calibration/calibration/optimization/constraints.py</code> <pre><code>def calculate_penalty(self, parameters: Dict[str, float]) -&gt; float:\n    \"\"\"Calculate total penalty for all violated constraints.\"\"\"\n    p = 0.0\n    for name, c in self.box_constraints.items():\n        v = c.violation(parameters.get(name, 0.0))\n        if v &gt; 0:\n            if c.hard:\n                return float(\"inf\")\n            p += self.penalty_function(v, self.penalty_weights.get(f\"box_{name}\", 1.0))\n    for i, c in enumerate(self.linear_constraints, 1):\n        v = c.violation(parameters)\n        if v &gt; 0:\n            p += self.penalty_function(v, self.penalty_weights.get(f\"linear_{i}\", 1.0))\n    for c in self.nonlinear_constraints:\n        v = c.violation(parameters)\n        if v &gt; 0:\n            p += self.penalty_function(v, self.penalty_weights.get(f\"nonlinear_{c.name}\", 1.0))\n    return p\n</code></pre>"},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.constraints.ParameterConstraints.get_scipy_constraints","title":"<code>get_scipy_constraints(parameter_names)</code>","text":"<p>Convert constraints to scipy format.</p> Source code in <code>pyadm1ode_calibration/calibration/optimization/constraints.py</code> <pre><code>def get_scipy_constraints(self, parameter_names: List[str]) -&gt; List[Dict]:\n    \"\"\"Convert constraints to scipy format.\"\"\"\n    scipy_constraints = []\n    for constraint in self.linear_constraints:\n        coef_array = np.array([constraint.coefficients.get(name, 0.0) for name in parameter_names])\n        if constraint.constraint_type == \"equality\":\n            scipy_constraints.append(\n                {\"type\": \"eq\", \"fun\": lambda x, c=coef_array, b=constraint.upper_bound: np.dot(c, x) - b}\n            )\n        else:\n            if constraint.lower_bound is not None:\n                scipy_constraints.append(\n                    {\"type\": \"ineq\", \"fun\": lambda x, c=coef_array, b=constraint.lower_bound: np.dot(c, x) - b}\n                )\n            if constraint.upper_bound is not None:\n                scipy_constraints.append(\n                    {\"type\": \"ineq\", \"fun\": lambda x, c=coef_array, b=constraint.upper_bound: b - np.dot(c, x)}\n                )\n    for constraint in self.nonlinear_constraints:\n\n        def constraint_func(x, names=parameter_names, func=constraint.function):\n            params = {name: val for name, val in zip(names, x)}\n            return func(params)\n\n        if constraint.constraint_type == \"equality\":\n            scipy_constraints.append({\"type\": \"eq\", \"fun\": constraint_func})\n        else:\n            scipy_constraints.append({\"type\": \"ineq\", \"fun\": lambda x, f=constraint_func: -f(x)})\n    return scipy_constraints\n</code></pre>"},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.constraints.ParameterConstraints.is_feasible","title":"<code>is_feasible(parameters)</code>","text":"<p>Check if parameters satisfy all hard constraints.</p> Source code in <code>pyadm1ode_calibration/calibration/optimization/constraints.py</code> <pre><code>def is_feasible(self, parameters: Dict[str, float]) -&gt; bool:\n    \"\"\"Check if parameters satisfy all hard constraints.\"\"\"\n    for c in self.box_constraints.values():\n        if c.hard and not c.is_feasible(parameters.get(c.parameter_name, 0.0)):\n            return False\n    for c in self.linear_constraints:\n        if not c.is_feasible(parameters):\n            return False\n    for c in self.nonlinear_constraints:\n        if not c.is_feasible(parameters):\n            return False\n    return True\n</code></pre>"},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.constraints.ParameterConstraints.project_to_feasible","title":"<code>project_to_feasible(parameters)</code>","text":"<p>Project parameters to feasible region (box constraints only).</p> Source code in <code>pyadm1ode_calibration/calibration/optimization/constraints.py</code> <pre><code>def project_to_feasible(self, parameters: Dict[str, float]) -&gt; Dict[str, float]:\n    \"\"\"Project parameters to feasible region (box constraints only).\"\"\"\n    projected = parameters.copy()\n    for name, constraint in self.box_constraints.items():\n        if name in projected:\n            projected[name] = constraint.project(projected[name])\n    return projected\n</code></pre>"},{"location":"api/optimization/#pyadm1ode_calibration.calibration.optimization.constraints.ParameterConstraints.validate_parameters","title":"<code>validate_parameters(parameters)</code>","text":"<p>Validate parameters and return detailed error messages.</p> Source code in <code>pyadm1ode_calibration/calibration/optimization/constraints.py</code> <pre><code>def validate_parameters(self, parameters: Dict[str, float]) -&gt; Tuple[bool, List[str]]:\n    \"\"\"Validate parameters and return detailed error messages.\"\"\"\n    errors = []\n    for name, constraint in self.box_constraints.items():\n        if name in parameters:\n            value = parameters[name]\n            if not constraint.is_feasible(value):\n                errors.append(\n                    f\"Parameter '{name}' = {value:.4f} violates bounds [{constraint.lower:.4f}, {constraint.upper:.4f}]\"\n                )\n    for i, constraint in enumerate(self.linear_constraints, 1):\n        if not constraint.is_feasible(parameters):\n            value = constraint.evaluate(parameters)\n            if constraint.constraint_type == \"equality\":\n                errors.append(f\"Linear constraint {i}: {value:.4f} != {constraint.upper_bound:.4f}\")\n            else:\n                if constraint.lower_bound and value &lt; constraint.lower_bound:\n                    errors.append(f\"Linear constraint {i}: {value:.4f} &lt; {constraint.lower_bound:.4f}\")\n                if constraint.upper_bound and value &gt; constraint.upper_bound:\n                    errors.append(f\"Linear constraint {i}: {value:.4f} &gt; {constraint.upper_bound:.4f}\")\n    for constraint in self.nonlinear_constraints:\n        if not constraint.is_feasible(parameters):\n            value = constraint.evaluate(parameters)\n            errors.append(\n                f\"Nonlinear constraint '{constraint.name}': g(x) = {value:.4f} violates \"\n                f\"{constraint.constraint_type} constraint\"\n            )\n    return len(errors) == 0, errors\n</code></pre>"},{"location":"architecture/","title":"Architektur","text":"<p>PyADM1ODE_calibration ist modular aufgebaut, um Flexibilit\u00e4t bei der Wahl von Algorithmen und Datenquellen zu gew\u00e4hrleisten.</p>"},{"location":"architecture/#systemubersicht","title":"System\u00fcbersicht","text":"<p>Die folgende Diagramm zeigt die Interaktion zwischen den Hauptkomponenten:</p> graph TD     A[Messdaten] --&gt; B[MeasurementData]     B --&gt; C[Calibrator]     D[PyADM1ODE Modell] --&gt; C     C --&gt; E[Optimizer]     E --&gt; F[PlantSimulator]     F --&gt; D     F --&gt; G[Objektfunktion]     G --&gt; E     E --&gt; H[CalibrationResult]"},{"location":"architecture/#datenfluss","title":"Datenfluss","text":"<ol> <li>Input: Messdaten werden \u00fcber <code>io.loaders</code> eingelesen.</li> <li>Validierung: <code>io.validation</code> pr\u00fcft die Datenqualit\u00e4t.</li> <li>Optimierung: Der <code>Calibrator</code> orchestriert den <code>Optimizer</code>, um Parameter zu finden, die den Fehler zwischen Simulation und Messung minimieren.</li> <li>Output: Ergebnisse werden als <code>CalibrationResult</code> zur\u00fcckgegeben und optional in der Datenbank gespeichert.</li> </ol>"},{"location":"architecture/#klassenhierarchie","title":"Klassenhierarchie","text":"<ul> <li>BaseCalibrator: Abstrakte Basisklasse.</li> <li>InitialCalibrator: Implementierung f\u00fcr Batch-Vorg\u00e4nge.</li> <li>OnlineCalibrator: Implementierung f\u00fcr Echtzeit-Anpassungen.</li> </ul>"},{"location":"development/","title":"Entwicklung","text":"<p>Informationen f\u00fcr Mitwirkende und Entwickler von PyADM1ODE_calibration.</p>"},{"location":"development/#entwicklungs-setup","title":"Entwicklungs-Setup","text":"<ol> <li>Repository klonen.</li> <li>Abh\u00e4ngigkeiten installieren: <code>pip install -e \".[dev,docs]\"</code>.</li> <li>Pre-commit Hooks installieren: <code>pre-commit install</code>.</li> </ol>"},{"location":"development/#code-style","title":"Code-Style","text":"<p>Wir verwenden: - Black f\u00fcr die Formatierung. - Ruff f\u00fcr das Linting. - Google-Style Docstrings f\u00fcr die Dokumentation.</p>"},{"location":"development/#tests","title":"Tests","text":"<p>F\u00fchren Sie Tests mit pytest aus:</p> <pre><code>pytest\n</code></pre> <p>Mit Coverage-Bericht:</p> <pre><code>pytest --cov=pyadm1ode_calibration\n</code></pre>"},{"location":"development/#dokumentation-bauen","title":"Dokumentation bauen","text":"<pre><code>mkdocs build\n</code></pre> <p>Um die Dokumentation lokal mit Live-Vorschau zu sehen:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"development/metrics/","title":"Dokumentations-Metriken","text":"<p>Dieser Dashboard gibt einen \u00dcberblick \u00fcber die Qualit\u00e4t und Vollst\u00e4ndigkeit der Dokumentation und des Codes von PyADM1ODE_calibration.</p>"},{"location":"development/metrics/#zusammenfassung","title":"\ud83d\udcca Zusammenfassung","text":"Metrik Status Wert Ziel API-Dokumentation \u2705 100.0% &gt;95% Testabdeckung \ud83d\udfe1 ~90% &gt;90% Veraltete Links \u2705 0 0 Build-Warnungen \u2705 0 0"},{"location":"development/metrics/#api-dokumentations-abdeckung","title":"\ud83d\udcc8 API-Dokumentations-Abdeckung","text":"<p>Die Abdeckung wird automatisch bei jedem Push mit <code>interrogate</code> gepr\u00fcft.</p> <pre><code>RESULT: PASSED (minimum: 95.0%, actual: 100.0%)\n</code></pre>"},{"location":"development/metrics/#test-statistiken","title":"\ud83e\uddea Test-Statistiken","text":"<ul> <li>Gesamt-Tests: 32</li> <li>Bestanden: 32</li> <li>Abdeckung: 90.2%</li> </ul>"},{"location":"development/metrics/#changelog-status","title":"\ud83d\udcdd Changelog-Status","text":"<p>Das Changelog wird automatisch mittels <code>git-cliff</code> aus den Commit-Nachrichten generiert, die dem Conventional Commits Standard entsprechen.</p> <p>Zuletzt aktualisiert: {{ now }}</p>"},{"location":"examples/","title":"Beispiele","text":"<p>Praktische Beispiele zur Verwendung der PyADM1ODE-Kalibrierung.</p>"},{"location":"examples/#workflow-beispiele","title":"Workflow-Beispiele","text":"<ul> <li>Kalibrierungs-Workflow: Schritt-f\u00fcr-Schritt-Kalibrierung eines Biogasanlagenmodells.</li> </ul>"},{"location":"examples/calibration_workflow/","title":"Kalibrierungs-Workflow","text":"<p>Dieser Workflow zeigt die schrittweise Kalibrierung eines Biogasanlagenmodells.</p>"},{"location":"examples/calibration_workflow/#schritte","title":"Schritte","text":"<ol> <li>Daten laden</li> <li>Vorverarbeitung</li> <li>Kalibrierung ausf\u00fchren</li> <li>Ergebnisse validieren</li> </ol>"},{"location":"usage/","title":"Nutzung","text":"<p>Dieser Bereich enth\u00e4lt detaillierte Anleitungen zur Verwendung von PyADM1ODE_calibration.</p>"},{"location":"usage/#kern-workflows","title":"Kern-Workflows","text":"<ul> <li>Batch-Kalibrierung: Initialkalibrierung basierend auf historischen Daten.</li> <li>Online-Rekalibrierung: Dynamische Anpassung im laufenden Betrieb.</li> </ul>"},{"location":"usage/#beispiele","title":"Beispiele","text":"<ul> <li>Vollst\u00e4ndiger Workflow: Ein Schritt-f\u00fcr-Schritt Beispiel von der Datenaufbereitung bis zur Ergebnisanalyse.</li> </ul>"},{"location":"usage/#datenformate","title":"Datenformate","text":"<p>Das Framework erwartet Messdaten als Zeitreihen. Stellen Sie sicher, dass Ihre CSV-Dateien eine <code>timestamp</code>-Spalte und entsprechende Spalten f\u00fcr die Zielgr\u00f6\u00dfen (z.B. <code>Q_ch4</code>, <code>pH</code>) enthalten.</p>"},{"location":"usage/calibration/","title":"Handbuch zur Modellkalibrierung","text":"<p>Dieses Handbuch behandelt die Parameterkalibrierung in PyADM1ODE, einschlie\u00dflich der Erstkalibrierung aus historischen Daten und der Online-Rekalibrierung w\u00e4hrend des Anlagenbetriebs.</p>"},{"location":"usage/calibration/#ubersicht","title":"\u00dcbersicht","text":"<p>Die Modellkalibrierung ist f\u00fcr eine genaue Biogasanlagensimulation unerl\u00e4sslich. PyADM1ODE bietet:</p> <ul> <li>Erstkalibrierung: Batch-Optimierung aus historischen Messdaten</li> <li>Online-Rekalibrierung: Adaptive Parameteranpassung w\u00e4hrend des Betriebs</li> <li>Sensitivit\u00e4tsanalyse: Identifizierung einflussreicher Parameter</li> <li>Identifizierbarkeitsbewertung: Erkennung von \u00dcberparametrisierung</li> <li>Validierungswerkzeuge: G\u00fctekriterien und Residualanalyse</li> </ul>"},{"location":"usage/calibration/#schnelleinstieg","title":"Schnelleinstieg","text":"<pre><code>from pyadm1ode_calibration.calibration import Calibrator\nfrom pyadm1ode_calibration.io import MeasurementData\n# Annahme: plant und feedstock sind von pyadm1ode verf\u00fcgbar\nfrom pyadm1ode import BiogasPlant\n\n# Anlage und Messungen laden\nplant = BiogasPlant.from_json(\"plant.json\", feedstock)\nmeasurements = MeasurementData.from_csv(\"plant_data.csv\")\n\n# Kalibrator erstellen\ncalibrator = Calibrator(plant)\n\n# Parameter kalibrieren\nresult = calibrator.run_initial_calibration(\n    measurements=measurements,\n    parameters=[\"k_dis\", \"k_hyd_ch\", \"Y_su\"],\n    objectives=[\"Q_ch4\", \"pH\"],\n    weights={\"Q_ch4\": 0.8, \"pH\": 0.2}\n)\n\n# Kalibrierte Parameter anwenden\nif result.success:\n    calibrator.apply_calibration(result)\n</code></pre>"},{"location":"usage/calibration/#erstkalibrierung","title":"Erstkalibrierung","text":"<p>Die Erstkalibrierung wird typischerweise mit 7-30 Tagen stabilen Anlagendaten durchgef\u00fchrt.</p>"},{"location":"usage/calibration/#wann-die-erstkalibrierung-genutzt-werden-sollte","title":"Wann die Erstkalibrierung genutzt werden sollte","text":"<p>Nutzen Sie die Erstkalibrierung, wenn Sie: - Historische Messdaten haben (\u2265 2 Wochen empfohlen) - Einen stabilen Anlagenbetrieb w\u00e4hrend des Zeitraums haben - Zuverl\u00e4ssige Messungen der Zielgr\u00f6\u00dfen (Gasproduktion, pH, VFA) haben - Bekannte Substratzulaufmengen und -zusammensetzungen haben</p>"},{"location":"usage/calibration/#online-rekalibrierung","title":"Online-Rekalibrierung","text":"<p>Die Online-Rekalibrierung erm\u00f6glicht die kontinuierliche Anpassung der Parameter w\u00e4hrend des Betriebs, um schleichende \u00c4nderungen der Substrateigenschaften oder Sensordrift auszugleichen.</p>"},{"location":"usage/calibration/#nutzung-des-online-kalibrators","title":"Nutzung des Online-Kalibrators","text":"<pre><code># Online-Rekalibrierung mit begrenzten \u00c4nderungen\nresult = calibrator.run_online_calibration(\n    measurements=recent_data,\n    parameters=[\"k_dis\", \"Y_su\"],\n    max_parameter_change=0.10,  # Max 10% \u00c4nderung\n    time_window=7,               # Nutze die letzten 7 Tage\n    method=\"nelder_mead\"         # Schneller lokaler Optimierer\n)\n\nif result.success:\n    calibrator.apply_calibration(result)\n</code></pre>"},{"location":"usage/calibration/#validierung-und-qualitatsprufung","title":"Validierung und Qualit\u00e4tspr\u00fcfung","text":""},{"location":"usage/calibration/#gutekriterien","title":"G\u00fctekriterien","text":"<p>Der <code>CalibrationValidator</code> bietet umfassende Metriken zur Bewertung der Kalibrierungsqualit\u00e4t.</p> Metrik Exzellent Gut Ausreichend Mangelhaft R\u00b2 &gt; 0.90 0.75-0.90 0.50-0.75 &lt; 0.50 NSE (Nash-Sutcliffe Efficiency) &gt; 0.90 0.70-0.90 0.50-0.70 &lt; 0.50 PBIAS (Percent Bias) &lt; \u00b15% \u00b15-\u00b110% \u00b110-\u00b125% &gt; \u00b125%"},{"location":"usage/calibration/#referenzen","title":"Referenzen","text":"<ol> <li>Batstone et al. (2002): Anaerobic Digestion Model No. 1 (ADM1). IWA Publishing.</li> <li>Gaida (2014): Dynamic real-time substrate feed optimization of anaerobic co-digestion plants. PhD thesis.</li> <li>Dochain &amp; Vanrolleghem (2001): Dynamical Modelling &amp; Estimation in Wastewater Treatment Processes.</li> </ol>"},{"location":"en/","title":"PyADM1ODE Calibration","text":"<p>Advanced parameter calibration framework for PyADM1ODE biogas plant models.</p> <p>PyADM1ODE_calibration provides a complete solution for the calibration of PyADM1ODE models:</p> <ul> <li>Initial Calibration: Batch optimization based on historical measurement data.</li> <li>Online Re-Calibration: Real-time parameter adjustment during plant operation.</li> <li>Multiple Optimization Algorithms: Differential Evolution, Nelder-Mead, L-BFGS-B, Particle Swarm.</li> <li>Multi-Objective Optimization: Balance multiple outputs (CH\u2084, pH, VFA) with weighted objectives.</li> <li>Comprehensive Validation: Goodness-of-fit metrics, residual analysis, cross-validation.</li> <li>Data Management: CSV/database import, validation, outlier detection, gap filling.</li> </ul>"},{"location":"en/#key-features","title":"Key Features","text":"<ul> <li>\ud83c\udfaf Precision: Highly accurate matching of ADM1 parameters to real plant data.</li> <li>\u26a1 Efficiency: Fast local optimizers for online use.</li> <li>\ud83d\udcca Analysis: Integrated sensitivity and identifiability analysis.</li> <li>\ud83d\udcbe Integration: Seamless connection to PostgreSQL databases and CSV workflows.</li> </ul>"},{"location":"en/#getting-started","title":"Getting Started","text":"<p>Start with the Installation and follow our Quickstart Guide.</p>"},{"location":"en/configuration/","title":"Configuration","text":"<p>PyADM1ODE_calibration can be configured in several ways to adapt the calibration process to your plant.</p>"},{"location":"en/configuration/#parameter-bounds","title":"Parameter Bounds","text":"<p>Default bounds for ADM1 parameters are defined in <code>ParameterBounds</code>. You can adjust them globally or per calibration.</p> <pre><code>from pyadm1ode_calibration.calibration import create_default_bounds\n\nbounds = create_default_bounds()\nbounds.add_bound(\"k_dis\", lower=0.3, upper=0.8, default=0.5)\n</code></pre>"},{"location":"en/configuration/#database-connection","title":"Database Connection","text":"<p>The connection to the PostgreSQL database is established via environment variables or a configuration object.</p>"},{"location":"en/configuration/#environment-variables","title":"Environment Variables","text":"Variable Description Default <code>DB_HOST</code> Database host <code>localhost</code> <code>DB_PORT</code> Port <code>5432</code> <code>DB_NAME</code> Database name - <code>DB_USER</code> Username - <code>DB_PASSWORD</code> Password -"},{"location":"en/configuration/#optimizer-settings","title":"Optimizer Settings","text":"<p>Each algorithm has specific parameters that are passed via <code>kwargs</code> to the <code>calibrate</code> method:</p> <ul> <li>Differential Evolution: <code>population_size</code>, <code>mutation</code>, <code>recombination</code>.</li> <li>Nelder-Mead: <code>adaptive</code>, <code>tolerance</code>.</li> <li>L-BFGS-B: <code>gtol</code>.</li> </ul>"},{"location":"en/configuration/#logging","title":"Logging","text":"<p>The framework uses the standard Python logging module. You can set the verbosity level as follows:</p> <pre><code>import logging\nlogging.getLogger(\"pyadm1ode_calibration\").setLevel(logging.DEBUG)\n</code></pre>"},{"location":"en/getting-started/","title":"Getting Started","text":"<p>This guide will help you get started with PyADM1ODE_calibration.</p>"},{"location":"en/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher.</li> <li>PyADM1ODE: The base package must be installed.</li> <li>Data: Historical biogas plant measurement data in CSV format (recommended).</li> </ul>"},{"location":"en/getting-started/#installation","title":"Installation","text":"<p>The easiest way is to install via pip directly from the repository:</p> <pre><code>pip install git+https://github.com/dgaida/PyADM1ODE_calibration.git\n</code></pre> <p>For developers, we recommend installing in editable mode:</p> <pre><code>git clone https://github.com/dgaida/PyADM1ODE_calibration.git\ncd PyADM1ODE_calibration\npip install -e .\n</code></pre>"},{"location":"en/getting-started/#quick-overview","title":"Quick Overview","text":"<p>A typical calibration workflow consists of four steps:</p> <ol> <li>Load Data: Import and validate your measurement data.</li> <li>Prepare Model: Configuration of your PyADM1ODE plant model.</li> <li>Run Calibration: Choose an algorithm and start the optimization.</li> <li>Verify Results: Validate parameters using goodness-of-fit metrics.</li> </ol> <p>Check the Calibration Example for a detailed code walkthrough.</p>"},{"location":"en/installation/","title":"Installation","text":"<p>Detailed instructions for installing PyADM1ODE_calibration in various environments.</p>"},{"location":"en/installation/#with-optional-dependencies","title":"With Optional Dependencies","text":"<pre><code># For development (tests, linting)\npip install \"pyadm1ode_calibration[dev] @ git+https://github.com/dgaida/PyADM1ODE_calibration.git\"\n\n# For documentation\npip install \"pyadm1ode_calibration[docs] @ git+https://github.com/dgaida/PyADM1ODE_calibration.git\"\n</code></pre>"},{"location":"en/installation/#conda-mamba","title":"Conda / Mamba","text":"<p>We recommend using a dedicated environment:</p> <pre><code># Create environment\nconda env create -f environment.yml\nconda activate biogas\n\n# Install package in development mode\npip install -e .\n</code></pre>"},{"location":"en/installation/#database-dependencies","title":"Database Dependencies","text":"<p>If you plan to use the PostgreSQL integration, ensure that the appropriate client libraries are installed on your system:</p> <ul> <li>Linux (Debian/Ubuntu): <code>sudo apt-get install libpq-dev</code></li> <li>macOS: <code>brew install postgresql</code></li> </ul>"},{"location":"en/installation/#verification","title":"Verification","text":"<p>After installation, you can verify it is working correctly:</p> <pre><code>import pyadm1ode_calibration\nprint(pyadm1ode_calibration.__version__)\n</code></pre>"},{"location":"en/troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and their solutions.</p>"},{"location":"en/troubleshooting/#simulation-does-not-converge","title":"Simulation does not converge","text":"<ul> <li>Cause: Too aggressive parameter changes or unstable initial values.</li> <li>Solution: Narrow the parameter <code>bounds</code> or use <code>max_parameter_change</code> during online calibration.</li> </ul>"},{"location":"en/troubleshooting/#database-connection-errors","title":"Database Connection Errors","text":"<ul> <li>Cause: Incorrect environment variables or missing permissions.</li> <li>Solution: Check <code>DB_HOST</code>, <code>DB_NAME</code> etc. Ensure PostgreSQL is running and accepting connections.</li> </ul>"},{"location":"en/troubleshooting/#slow-calibration","title":"Slow Calibration","text":"<ul> <li>Cause: Too many parameters or too many iterations in Differential Evolution.</li> <li>Solution: Perform a sensitivity analysis first to identify the most important parameters. Use local optimizers (Nelder-Mead) for fine-tuning.</li> </ul>"},{"location":"en/architecture/","title":"Architecture","text":"<p>PyADM1ODE_calibration is built modularly to ensure flexibility in the choice of algorithms and data sources.</p>"},{"location":"en/architecture/#system-overview","title":"System Overview","text":"<p>The following diagram shows the interaction between the main components:</p> graph TD     A[Measurement Data] --&gt; B[MeasurementData]     B --&gt; C[Calibrator]     D[PyADM1ODE Model] --&gt; C     C --&gt; E[Optimizer]     E --&gt; F[PlantSimulator]     F --&gt; D     F --&gt; G[Objective Function]     G --&gt; E     E --&gt; H[CalibrationResult]"},{"location":"en/architecture/#data-flow","title":"Data Flow","text":"<ol> <li>Input: Measurement data is read via <code>io.loaders</code>.</li> <li>Validation: <code>io.validation</code> checks data quality.</li> <li>Optimization: The <code>Calibrator</code> orchestrates the <code>Optimizer</code> to find parameters that minimize the error between simulation and measurement.</li> <li>Output: Results are returned as <code>CalibrationResult</code> and optionally stored in the database.</li> </ol>"},{"location":"en/architecture/#class-hierarchy","title":"Class Hierarchy","text":"<ul> <li>BaseCalibrator: Abstract base class.</li> <li>InitialCalibrator: Implementation for batch processes.</li> <li>OnlineCalibrator: Implementation for real-time adjustments.</li> </ul>"},{"location":"en/development/","title":"Development","text":"<p>Information for contributors and developers of PyADM1ODE_calibration.</p>"},{"location":"en/development/#development-setup","title":"Development Setup","text":"<ol> <li>Clone the repository.</li> <li>Install dependencies: <code>pip install -e \".[dev,docs]\"</code>.</li> <li>Install pre-commit hooks: <code>pre-commit install</code>.</li> </ol>"},{"location":"en/development/#code-style","title":"Code Style","text":"<p>We use: - Black for formatting. - Ruff for linting. - Google-style docstrings for documentation.</p>"},{"location":"en/development/#tests","title":"Tests","text":"<p>Run tests with pytest:</p> <pre><code>pytest\n</code></pre> <p>With coverage report:</p> <pre><code>pytest --cov=pyadm1ode_calibration\n</code></pre>"},{"location":"en/development/#building-documentation","title":"Building Documentation","text":"<pre><code>mkdocs build\n</code></pre> <p>To view the documentation locally with live preview:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"en/development/metrics/","title":"Documentation Metrics","text":"<p>This dashboard provides an overview of the quality and completeness of the PyADM1ODE_calibration documentation and code.</p>"},{"location":"en/development/metrics/#summary","title":"\ud83d\udcca Summary","text":"Metric Status Value Target API Documentation \u2705 100.0% &gt;95% Test Coverage \ud83d\udfe1 ~90% &gt;90% Broken Links \u2705 0 0 Build Warnings \u2705 0 0"},{"location":"en/development/metrics/#api-documentation-coverage","title":"\ud83d\udcc8 API Documentation Coverage","text":"<p>Coverage is automatically checked on every push using <code>interrogate</code>.</p> <pre><code>RESULT: PASSED (minimum: 95.0%, actual: 100.0%)\n</code></pre>"},{"location":"en/development/metrics/#test-statistics","title":"\ud83e\uddea Test Statistics","text":"<ul> <li>Total Tests: 32</li> <li>Passed: 32</li> <li>Coverage: 90.2%</li> </ul>"},{"location":"en/development/metrics/#changelog-status","title":"\ud83d\udcdd Changelog Status","text":"<p>The changelog is automatically generated using <code>git-cliff</code> from commit messages following the Conventional Commits standard.</p> <p>Last updated: {{ now }}</p>"},{"location":"en/examples/","title":"Examples","text":"<p>Practical examples of using PyADM1ODE Calibration.</p>"},{"location":"en/examples/#workflow-examples","title":"Workflow Examples","text":"<ul> <li>Calibration Workflow: Step-by-step calibration of a biogas plant model.</li> </ul>"},{"location":"en/examples/calibration_workflow/","title":"TODO: Generate this file","text":"<ul> <li>Complete step-by-step guide</li> <li>Real data example</li> <li>Troubleshooting tips</li> </ul>"},{"location":"en/usage/","title":"Usage","text":"<p>This section contains detailed guides on how to use PyADM1ODE_calibration.</p>"},{"location":"en/usage/#core-workflows","title":"Core Workflows","text":"<ul> <li>Batch Calibration: Initial calibration based on historical data.</li> <li>Online Re-Calibration: Dynamic adjustment during operation.</li> </ul>"},{"location":"en/usage/#examples","title":"Examples","text":"<ul> <li>Complete Workflow: A step-by-step example from data preparation to results analysis.</li> </ul>"},{"location":"en/usage/#data-formats","title":"Data Formats","text":"<p>The framework expects measurement data as time series. Ensure your CSV files contain a <code>timestamp</code> column and corresponding columns for the objectives (e.g., <code>Q_ch4</code>, <code>pH</code>).</p>"},{"location":"en/usage/calibration/","title":"Model Calibration Guide","text":"<p>This guide covers parameter calibration in PyADM1ODE, including initial calibration from historical data and online re-calibration during plant operation.</p>"},{"location":"en/usage/calibration/#overview","title":"Overview","text":"<p>Model calibration is essential for accurate biogas plant simulation. PyADM1ODE provides:</p> <ul> <li>Initial Calibration: Batch optimization from historical measurement data</li> <li>Online Re-calibration: Adaptive parameter adjustment during operation</li> <li>Sensitivity Analysis: Identification of influential parameters</li> <li>Identifiability Assessment: Detection of over-parameterization</li> <li>Validation Tools: Goodness-of-fit metrics and residual analysis</li> </ul>"},{"location":"en/usage/calibration/#quick-start","title":"Quick Start","text":"<pre><code>from pyadm1ode_calibration.calibration import Calibrator\nfrom pyadm1ode_calibration.io import MeasurementData\n# Assuming plant and feedstock are available from pyadm1ode\nfrom pyadm1ode import BiogasPlant\n\n# Load plant and measurements\nplant = BiogasPlant.from_json(\"plant.json\", feedstock)\nmeasurements = MeasurementData.from_csv(\"plant_data.csv\")\n\n# Create calibrator\ncalibrator = Calibrator(plant)\n\n# Calibrate parameters\nresult = calibrator.run_initial_calibration(\n    measurements=measurements,\n    parameters=[\"k_dis\", \"k_hyd_ch\", \"Y_su\"],\n    objectives=[\"Q_ch4\", \"pH\"],\n    weights={\"Q_ch4\": 0.8, \"pH\": 0.2}\n)\n\n# Apply calibrated parameters\nif result.success:\n    calibrator.apply_calibration(result)\n</code></pre>"},{"location":"en/usage/calibration/#initial-calibration","title":"Initial Calibration","text":"<p>The initial calibration is typically performed using 7-30 days of stable plant operation data.</p>"},{"location":"en/usage/calibration/#when-to-use-initial-calibration","title":"When to Use Initial Calibration","text":"<p>Use initial calibration when you have: - Historical measurement data (\u22652 weeks recommended) - Stable plant operation during measurement period - Reliable measurements of key outputs (gas production, pH, VFA) - Known substrate feed rates and composition</p>"},{"location":"en/usage/calibration/#parameter-selection","title":"Parameter Selection","text":"<p>Choose parameters based on:</p> <p>High Priority (most sensitive to calibration): - <code>k_dis</code>: Disintegration rate [1/d] - <code>k_hyd_ch</code>, <code>k_hyd_pr</code>, <code>k_hyd_li</code>: Hydrolysis rates [1/d] - <code>Y_su</code>, <code>Y_aa</code>: Yield coefficients [kg COD/kg COD]</p> <p>Medium Priority: - <code>k_m_c4</code>, <code>k_m_pro</code>, <code>k_m_ac</code>, <code>k_m_h2</code>: Maximum uptake rates [1/d] - <code>K_S_su</code>, <code>K_S_aa</code>: Half-saturation constants [kg COD/m\u00b3]</p> <p>Low Priority (usually well-defined): - Stoichiometric coefficients (C, N content) - Physical-chemical constants (K_a, K_H)</p>"},{"location":"en/usage/calibration/#online-re-calibration","title":"Online Re-Calibration","text":"<p>Online re-calibration allows for continuous adjustment of parameters during operation to account for gradual changes in substrate properties or equipment drift.</p>"},{"location":"en/usage/calibration/#using-the-online-calibrator","title":"Using the Online Calibrator","text":"<pre><code># Re-calibrate with bounded changes\nresult = calibrator.run_online_calibration(\n    measurements=recent_data,\n    parameters=[\"k_dis\", \"Y_su\"],\n    max_parameter_change=0.10,  # Max 10% change\n    time_window=7,               # Use last 7 days\n    method=\"nelder_mead\"         # Fast local optimization\n)\n\nif result.success:\n    calibrator.apply_calibration(result)\n</code></pre>"},{"location":"en/usage/calibration/#when-to-use-online-re-calibration","title":"When to Use Online Re-Calibration","text":"<p>Appropriate for: - Long-term operation (months) - Gradual substrate property changes - Seasonal variations - Equipment drift</p>"},{"location":"en/usage/calibration/#validation-and-quality-checks","title":"Validation and Quality Checks","text":""},{"location":"en/usage/calibration/#goodness-of-fit-metrics","title":"Goodness-of-Fit Metrics","text":"<p>The <code>CalibrationValidator</code> provides comprehensive metrics to assess the quality of the calibration.</p> Metric Excellent Good Fair Poor R\u00b2 &gt; 0.90 0.75-0.90 0.50-0.75 &lt; 0.50 NSE (Nash-Sutcliffe Efficiency) &gt; 0.90 0.70-0.90 0.50-0.70 &lt; 0.50 PBIAS (Percent Bias) &lt; \u00b15% \u00b15-\u00b110% \u00b110-\u00b125% &gt; \u00b125%"},{"location":"en/usage/calibration/#references","title":"References","text":"<ol> <li>Batstone et al. (2002): Anaerobic Digestion Model No. 1 (ADM1). IWA Publishing.</li> <li>Gaida (2014): Dynamic real-time substrate feed optimization of anaerobic co-digestion plants. PhD thesis.</li> <li>Dochain &amp; Vanrolleghem (2001): Dynamical Modelling &amp; Estimation in Wastewater Treatment Processes.</li> </ol>"}]}